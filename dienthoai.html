<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <!-- THAY ĐỔI: Viewport rất quan trọng cho mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>The King - Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* CSS cho Game (Đã sửa cho Mobile) */
        :root {
            --grid-size: 25px; 
            --font-family: 'Press Start 2P', cursive;
            --font-size-small: 8px;
            --font-size-base: 10px;
            --font-size-header: 14px;
            
            /* Màu sắc (Giữ nguyên) */
            --color-grass: #2a9d8f;
            --color-path: #8d6e63;
            --color-water: #4a90e2;
            --color-rock: #6c757d;
            --color-castle: #a8dadc;
            --color-ui-bg: #264653;
            --color-ui-border: #1e3a47;
            --color-font-main: #e9c46a;
            --color-font-light: #f1faee;
            --color-font-danger: #e63946;
            --color-house: #f4a261;
            --color-farm: #b5835a; 
            --color-farmplot: #e9c46a; 
            --color-clinic: #f1faee;
            --color-barracks: #cd853f; 
            --color-wall: #c9ada7;
            --color-tower: #e76f51; 
            --color-shipyard: #457b9d; 
            --color-enemy: #d62828;
            --color-orc: #228b22; 
            --color-catapult: #593b2b; 
            --color-soldier: #0077b6;
            --color-projectile: #f1faee;
        }

        body {
            font-family: var(--font-family);
            background-color: #1a1a1a;
            color: var(--color-font-main);
            margin: 0;
            /* THAY ĐỔI: Chỉnh layout full màn hình */
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-size: var(--font-size-base);
            display: flex;
            flex-direction: column;
        }

        /* THAY ĐỔI: Container chính của game */
        #game-container {
            display: flex;
            flex-direction: column; /* Xếp dọc */
            width: 100%;
            height: 100%;
            max-width: 600px; /* Giới hạn chiều rộng trên tablet/PC */
            margin: 0 auto; /* Căn giữa */
            border: 4px solid var(--color-ui-bg);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: var(--color-ui-bg);
            box-sizing: border-box;
        }
        
        /* THAY ĐỔI: Màn hình Game (Canvas) */
        #game-canvas {
            width: 100%; /* Chiếm 100% chiều rộng */
            height: auto; /* Chiều cao tự động */
            aspect-ratio: 1 / 1; /* Giữ tỷ lệ 1:1 */
            background-color: var(--color-grass);
            cursor: crosshair;
            image-rendering: pixelated;
            flex-shrink: 0; /* Không co lại */
        }

        /* THAY ĐỔI: Giao diện người dùng (Shop, Thông tin) */
        #ui-panel {
            width: 100%;
            flex: 1; /* Chiếm phần còn lại */
            overflow-y: auto; /* Cho phép cuộn dọc */
            padding: 15px;
            display: flex;
            flex-direction: column;
            background-color: var(--color-ui-bg);
            border-top: 4px solid var(--color-ui-border); /* Chuyển border */
            color: var(--color-font-light);
            font-size: var(--font-size-small);
            box-sizing: border-box; /* Tính cả padding */
        }

        /* Bảng thông số game */
        #game-stats {
            width: 100%;
            border-bottom: 2px solid var(--color-font-main);
            padding-bottom: 10px;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        #game-stats div {
            font-size: var(--font-size-base);
            color: var(--color-font-main);
            width: 100%;
        }
        #money-display {
            text-align: right;
            color: #f1c40f; 
        }

        h2 {
            font-size: var(--font-size-header);
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--color-font-main);
            border-bottom: 2px solid var(--color-font-main);
            padding-bottom: 5px;
        }

        /* THAY ĐỔI: Cửa hàng (Shop) - Dạng cuộn ngang */
        #shop {
            display: flex; /* Dạng flex */
            overflow-x: auto; /* Cuộn ngang */
            gap: 8px;
            margin-bottom: 15px;
            padding-bottom: 5px; /* Chỗ cho thanh cuộn */
        }

        .shop-item {
            flex-shrink: 0; /* Không co item */
            width: 100px; /* Chiều rộng cố định */
            padding: 8px 5px;
            background-color: #457b9d;
            color: var(--color-font-light);
            text-align: center;
            cursor: pointer;
            border-radius: 5px;
            border: 2px solid #a8dadc;
            transition: background-color 0.2s, transform 0.2s;
            line-height: 1.3;
        }
        /* (Các style :hover, .selected, .disabled giữ nguyên) */
        .shop-item:hover {
            background-color: #1d3557;
            transform: scale(1.05);
        }

        .shop-item.selected {
            background-color: var(--color-font-danger);
            border-color: var(--color-font-light);
        }
        
        .shop-item.disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .cost {
            font-size: 7px;
            color: #f1c40f;
            display: block;
            margin-top: 2px;
        }

        /* Bảng Nâng cấp */
        #upgrade-panel {
            border-top: 2px solid var(--color-font-main);
            padding-top: 10px;
            margin-top: auto; 
            display: none; 
        }
        
        #upgrade-panel h3 {
            font-size: var(--font-size-base);
            margin: 0 0 5px 0;
            color: var(--color-font-main);
            text-align: center;
        }
        
        #upgrade-stats {
            font-size: var(--font-size-small);
            line-height: 1.4;
            margin-bottom: 10px;
        }

        #upgrade-button {
            width: 100%;
            padding: 10px;
            background-color: #38a3a5;
            color: var(--color-font-light);
            border: none;
            border-radius: 5px;
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            cursor: pointer;
        }
        
        #upgrade-button:hover {
            background-color: #2a9d8f;
        }
        
        #upgrade-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        #sell-button {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: var(--color-font-danger);
            color: var(--color-font-light);
            border: none;
            border-radius: 5px;
            font-family: var(--font-family);
            font-size: var(--font-size-small);
            cursor: pointer;
        }

        /* Thông báo */
        #message-display {
            font-size: 9px;
            height: 30px;
            border-top: 2px solid var(--color-font-main);
            padding-top: 10px;
            margin-top: 10px;
            color: var(--color-font-danger);
            text-align: center;
            line-height: 1.3;
        }
    </style>
</head>
<body>

    <!-- THAY ĐỔI: Cấu trúc HTML (Canvas ở trên, UI ở dưới) -->
    <div id="game-container">
        
        <canvas id="game-canvas" width="600" height="600"></canvas>
        
        <div id="ui-panel">
            
            <div id="game-stats">
                <div id="day-display">Ngày: 1</div>
                <div id="money-display">Tiền: 100$</div>
                <div id="castle-health-display">Lâu Đài: 100 HP</div>
                <div id="population-display">Lính: 0</div>
            </div>

            <h2>Cửa Hàng</h2>
            <div id="shop">
                <!-- (Giữ nguyên các shop-item) -->
                <div class="shop-item" data-type="house" data-cost="10">
                    Nhà Nhỏ (+3$/ngày)
                    <span class="cost">Giá: 10$</span>
                </div>
                <div class="shop-item" data-type="farm" data-cost="15">
                    Nhà Gia Súc (+5$/ngày)
                    <span class="cost">Giá: 15$</span>
                </div>
                <div class="shop-item" data-type="farmplot" data-cost="10">
                    Ruộng Vàng (+10% Thuế)
                    <span class="cost">Giá: 10$</span>
                </div>
                <div class="shop-item" data-type="clinic" data-cost="15">
                    Bệnh Xá (+1 lính/đêm/Lv)
                    <span class="cost">Giá: 20$</span>
                </div>
                <div class="shop-item" data-type="barracks" data-cost="30">
                    Túp Lều (Kiếm Gỗ - 5 Lính)
                    <span class="cost">Giá: 30$</span>
                </div>
                <div class="shop-item" data-type="wall" data-cost="5">
                    Hàng Rào (HP Cao)
                    <span class="cost">Giá: 5$</span>
                </div>
                <div class="shop-item" data-type="tower" data-cost="30">
                    Tháp Canh (Tầm: 5)
                    <span class="cost">Giá: 30$</span>
                </div>
                <div class="shop-item" data-type="shipyard" data-cost="50">
                    Xưởng Tàu (Tầm: 30)
                    <span class="cost">Giá: 50$</span>
                </div>
            </div>
            
            <div id="message-display">Chào mừng, Nhà Vua! (Tap 1 lính để chọn, Tap đất trống để di chuyển)</div>
            
            <div id="upgrade-panel">
                <h3 id="upgrade-title">Nâng Cấp</h3>
                <div id="upgrade-stats">
                    <div id="upgrade-level">Level: 1</div>
                    <div id="upgrade-health">Máu: 50/50</div>
                    <div id="upgrade-info"></div>
                </div>
                <button id="upgrade-button">Nâng Cấp (5$)</button>
                <button id="sell-button">Bán (5$)</button>
            </div>
        </div>
        
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- Cài đặt Game ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false; 

            // (Giữ nguyên COLORS, WEAPONS, GRID_SIZE, COLS, ROWS, v.v.)
            const COLORS = {
                grass: '#2a9d8f', path: '#8d6e63', water: '#4a90e2', rock: '#6c757d',
                castle: '#a8dadc', house: '#f4a261', 
                farm: '#b5835a', farmplot: '#e9c46a', clinic: '#f1faee', 
                barracks: '#cd853f', wall: '#c9ada7', tower: '#e76f51', 
                shipyard: '#457b9d', enemy: '#d62828', orc: '#228b22', 
                catapult: '#593b2b', soldier: '#0077b6', projectile: '#f1faee'
            };
            const WEAPONS = [
                { name: 'Kiếm Gỗ', damage: 2, color: '#8b4513' },
                { name: 'Kiếm Đá', damage: 4, color: '#a9a9a9' },
                { name: 'Kiếm Sắt', damage: 12, color: '#cccccc' },
                { name: 'Kiếm Kim Cương', damage: 16, color: '#33ccff' }
            ];
            const getWeaponByLevel = (level) => {
                return WEAPONS[Math.min(level - 1, WEAPONS.length - 1)];
            };
            const getRandomWeapon = () => {
                return WEAPONS[Math.floor(Math.random() * WEAPONS.length)];
            };
            const GRID_SIZE = 25;
            const COLS = canvas.width / GRID_SIZE; // 24
            const ROWS = canvas.height / GRID_SIZE; // 24
            const MID_X = Math.floor(COLS / 2);
            const MID_Y = Math.floor(ROWS / 2);

            let money = 500;
            let day = 1;
            let castleHealth = 100;
            let maxCastleHealth = 100;
            let castleLevel = 1; 
            let population = 0;
            let gameOver = false;
            let gameTime = 0; 
            let isNight = false;
            let hasSpawnedTonight = false; 

            let grid = []; 
            let entities = []; 
            let units = []; 
            let projectiles = []; 

            let selectedShopItem = null; 
            let selectedEntity = null; 
            let selectedSoldier = null; 
            
            let mousePos = { x: 0, y: 0, gridX: 0, gridY: 0 };

            const DAY_LENGTH_MS = 30000; 
            const NIGHT_START_RATIO = 0.75; 
            let dayTimerDisplay = DAY_LENGTH_MS / 1000;

            let enemyStats = {
                spawnCount: 2,
                health: 10,
                damage: 2,
                speed: 0.6
            };
            const spawnSides = [
                { gridX: COLS / 2, gridY: 0 }, // Trên
                { gridX: COLS / 2, gridY: ROWS - 1 }, // Dưới
                { gridX: 0, gridY: ROWS / 2 }, // Trái
                { gridX: COLS - 1, gridY: ROWS / 2 } // Phải
            ];
            
            // (Giữ nguyên các element UI)
            const moneyDisplay = document.getElementById('money-display');
            const dayDisplay = document.getElementById('day-display');
            const castleHealthDisplay = document.getElementById('castle-health-display');
            const populationDisplay = document.getElementById('population-display');
            const messageDisplay = document.getElementById('message-display');
            const shopItems = document.querySelectorAll('.shop-item');
            const upgradePanel = document.getElementById('upgrade-panel');
            const upgradeTitle = document.getElementById('upgrade-title');
            const upgradeLevel = document.getElementById('upgrade-level');
            const upgradeHealth = document.getElementById('upgrade-health');
            const upgradeInfo = document.getElementById('upgrade-info');
            const upgradeButton = document.getElementById('upgrade-button');
            const sellButton = document.getElementById('sell-button');

            // --- Lớp (Classes) ---
            // (Giữ nguyên toàn bộ các Class: Entity, Castle, House, FarmPlot, Clinic, Barracks, Wall, Tower, Shipyard, Warship)
            class Entity {
                constructor(x, y, type, cost, health) {
                    this.x = x * GRID_SIZE;
                    this.y = y * GRID_SIZE;
                    this.gridX = x;
                    this.gridY = y;
                    this.size = GRID_SIZE;
                    this.type = type;
                    this.cost = cost;
                    this.health = health;
                    this.maxHealth = health;
                    this.level = 1;
                    this.id = Math.random();
                }
                draw() {
                    ctx.fillStyle = '#ccc'; // Màu mặc định
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    this.drawHealthBar();
                    if(selectedEntity === this) {
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x - 1, this.y - 1, this.size + 2, this.size + 2);
                        ctx.lineWidth = 1;
                    }
                }
                drawHealthBar() {
                    if (this.health < this.maxHealth || this.type === 'castle') {
                        const barWidth = this.size;
                        const barHeight = 4;
                        const drawX = this.x + (this.type === 'castle' ? this.size/4 : 0);
                        const drawWidth = this.type === 'castle' ? this.size/2 : barWidth;
                        ctx.fillStyle = '#333';
                        ctx.fillRect(drawX, this.y - barHeight - 2, drawWidth, barHeight);
                        ctx.fillStyle = this.type === 'castle' ? '#4a90e2' : 'green';
                        ctx.fillRect(drawX, this.y - barHeight - 2, drawWidth * (this.health / this.maxHealth), barHeight);
                    }
                }
                update() {}
                getUpgradeCost() { return 5 * this.level; }
                getSellValue() { return Math.floor(this.cost / 2); }
                upgrade() {
                    if (this.level >= 10 && this.type !== 'castle') {
                        logMessage("Đã đạt cấp tối đa (Level 10)!");
                        return;
                    }
                    const cost = this.getUpgradeCost();
                    if (money >= cost) {
                        money -= cost;
                        this.level++;
                        if (this.type === 'castle') {
                            this.maxHealth = Math.floor(this.maxHealth * 1.2); 
                            this.health = this.maxHealth; 
                            castleLevel = this.level;
                        } else {
                            this.maxHealth += Math.floor(this.maxHealth * 1.2); 
                            this.health = this.maxHealth;
                        }
                        logMessage(`${this.type} đã lên Cấp ${this.level}!`);
                        this.applyUpgrade();
                        selectEntityForUpgrade(this);
                    } else {
                        logMessage("Không đủ tiền nâng cấp!");
                    }
                }
                applyUpgrade() {}
                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.destroy();
                    }
                }
                destroy() {
                    this.health = 0;
                    if(grid[this.gridY] && grid[this.gridY][this.gridX] === 3) {
                         grid[this.gridY][this.gridX] = 0; 
                    }
                    else if(grid[this.gridY] && grid[this.gridY][this.gridX] === 6) { 
                         grid[this.gridY][this.gridX] = 1; 
                    }
                    if(this.type === 'shipyard') {
                        grid[this.gridY][this.gridX] = 0;
                    }
                    if(this.warship) this.warship.destroy();
                    if(this.soldiers) this.soldiers.forEach(s => s.destroy());
                    if(selectedEntity === this) {
                        hideUpgradePanel();
                    }
                }
            }
            class Castle extends Entity {
                constructor(x, y) {
                    super(x, y, 'castle', 0, maxCastleHealth);
                    this.size = GRID_SIZE * 2;
                    this.level = 1;
                }
                draw() {
                    ctx.fillStyle = COLORS.castle;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = '25px "Press Start 2P"';
                    ctx.fillText("♔", this.x + 8, this.y + 35);
                    ctx.font = '8px "Press Start 2P"';
                    ctx.fillText(`Lv${this.level}`, this.x + 5, this.y + 10);
                    this.drawHealthBar();
                }
                takeDamage(amount) {
                    this.health -= amount;
                    castleHealth = this.health;
                    if (this.health <= 0 && !gameOver) {
                        gameOver = true;
                        this.health = 0;
                        logMessage("GAME OVER! Lâu đài đã bị phá hủy.");
                    }
                }
                getUpgradeCost() { return 10 * this.level; } 
                getSellValue() { return 0; }
                select() {
                    selectEntityForUpgrade(this);
                }
            }
            class House extends Entity {
                constructor(x, y, type, cost, health, income) {
                    const baseIncome = (type === 'house') ? 3 : 5; 
                    super(x, y, type, cost, health);
                    this.income = baseIncome;
                }
                draw() {
                    if (this.type === 'house') {
                        ctx.fillStyle = '#fef08a'; 
                        ctx.fillRect(this.x, this.y + 10, this.size, this.size - 10);
                        ctx.fillStyle = '#8b4513'; 
                        ctx.fillRect(this.x + 9, this.y + 15, 7, 10);
                        ctx.fillStyle = '#d62828'; 
                        ctx.beginPath();
                        ctx.moveTo(this.x - 2, this.y + 12);
                        ctx.lineTo(this.x + this.size / 2, this.y - 2);
                        ctx.lineTo(this.x + this.size + 2, this.y + 12);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.fillStyle = COLORS.farm; 
                        ctx.fillRect(this.x, this.y, this.size, this.size);
                        ctx.strokeStyle = '#000';
                        ctx.strokeRect(this.x, this.y, this.size, this.size);
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.x + 2, this.y + 15, this.size - 4, 8);
                        ctx.fillRect(this.x + 5, this.y + 10, 3, 13);
                        ctx.fillRect(this.x + 12, this.y + 10, 3, 13);
                        ctx.fillRect(this.x + 19, this.y + 10, 3, 13);
                        ctx.fillStyle = '#fff'; 
                        ctx.fillRect(this.x + 5, this.y + 5, 5, 5);
                        ctx.fillStyle = '#ffc0cb'; 
                        ctx.fillRect(this.x + 15, this.y + 8, 5, 4);
                    }
                    this.drawHealthBar(); 
                }
                applyUpgrade() {
                    this.income += (this.type === 'house') ? 3 : 5; 
                }
            }
            class FarmPlot extends Entity { 
                constructor(x, y) {
                    super(x, y, 'farmplot', 13, 30);
                    this.buffBonus = 0.1; 
                }
                draw() {
                    ctx.fillStyle = COLORS.farmplot; 
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.strokeStyle = '#b5835a'; 
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 5, this.y); ctx.lineTo(this.x + 5, this.y + this.size);
                    ctx.moveTo(this.x + 12, this.y); ctx.lineTo(this.x + 12, this.y + this.size);
                    ctx.moveTo(this.x + 19, this.y); ctx.lineTo(this.x + 19, this.y + this.size);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                    this.drawHealthBar(); 
                }
                applyUpgrade() {
                    this.buffBonus += 0.2; 
                    logMessage(`Buff thuế của Ruộng tăng lên ${Math.round(this.buffBonus * 100)}%`);
                }
            }
            class Clinic extends Entity {
                constructor(x, y) {
                    super(x, y, 'clinic', 30, 60);
                }
                draw() {
                    ctx.fillStyle = COLORS.clinic; 
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = '#556b2f'; 
                    ctx.fillRect(this.x, this.y + this.size - 3, 5, 3);
                    ctx.fillRect(this.x + 10, this.y + this.size - 2, 7, 2);
                    ctx.fillRect(this.x + 20, this.y + this.size - 4, 5, 4);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = '#a9a9a9';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.size / 2, this.y - this.size / 3);
                    ctx.lineTo(this.x + this.size, this.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = COLORS.enemy;
                    ctx.fillRect(this.x + 10, this.y + 5, 5, 15);
                    ctx.fillRect(this.x + 5, this.y + 10, 15, 5);
                    this.drawHealthBar();
                }
                applyUpgrade() {}
            }
            class Barracks extends Entity {
                constructor(x, y) {
                    super(x, y, 'barracks', 40, 80);
                    this.soldiers = [];
                    this.maxSoldiers = 5;
                    this.spawnCooldown = 0;
                    this.soldierBaseDamage = 2; 
                    this.currentWeaponLevel = 1; 
                    this.spawnSoldiers(); 
                }
                spawnSoldiers(count = this.maxSoldiers) {
                     for(let i=0; i < count; i++) {
                        if(this.soldiers.length < this.maxSoldiers) {
                            const spawnPos = findEmptyNeighbor(this.gridX, this.gridY);
                            if(spawnPos) {
                                const weapon = getWeaponByLevel(this.currentWeaponLevel);
                                const newSoldier = new Soldier(
                                    spawnPos.x * GRID_SIZE, 
                                    spawnPos.y * GRID_SIZE, 
                                    this, 
                                    this.soldierBaseDamage, 
                                    weapon
                                );
                                units.push(newSoldier);
                                this.soldiers.push(newSoldier);
                                population++;
                            }
                        }
                    }
                }
                update() {
                    this.soldiers = this.soldiers.filter(s => s.health > 0);
                    if(this.spawnCooldown > 0) this.spawnCooldown--;
                }
                draw() {
                    ctx.fillStyle = COLORS.barracks; 
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x + this.size / 2, this.y + 5);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size / 2 - 4, this.y + this.size);
                    ctx.lineTo(this.x + this.size / 2, this.y + 15);
                    ctx.lineTo(this.x + this.size / 2 + 4, this.y + this.size);
                    ctx.closePath();
                    ctx.fill();
                    const weapon = getWeaponByLevel(this.currentWeaponLevel);
                    ctx.fillStyle = weapon.color;
                    ctx.font = '15px "Press Start 2P"';
                    ctx.fillText("⚔", this.x + 4, this.y + 18);
                    this.drawHealthBar();
                }
                applyUpgrade() {
                    this.maxSoldiers++;
                    if(this.level <= WEAPONS.length) {
                        this.currentWeaponLevel = this.level;
                    }
                    this.soldierBaseDamage *= 1.2;
                    this.soldiers.forEach(s => {
                        s.baseDamage = this.soldierBaseDamage;
                        s.weapon = getWeaponByLevel(this.currentWeaponLevel);
                        s.damage = s.weapon.damage * s.baseDamage;
                    });
                    this.spawnSoldiers(1); 
                }
                destroy() {
                    super.destroy();
                    this.soldiers.forEach(s => s.destroy());
                }
            }
            class Wall extends Entity {
                constructor(x, y) {
                    super(x, y, 'wall', 5, 250);
                }
                draw() {
                    ctx.fillStyle = '#a9a9a9'; 
                    ctx.beginPath();
                    ctx.moveTo(this.x + 2, this.y + this.size - 2);
                    ctx.lineTo(this.x + 8, this.y + 5);
                    ctx.lineTo(this.x + 14, this.y + this.size - 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(this.x + 11, this.y + this.size - 2);
                    ctx.lineTo(this.x + 17, this.y + 5);
                    ctx.lineTo(this.x + 23, this.y + this.size - 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#6c757d'; 
                    ctx.beginPath();
                    ctx.moveTo(this.x + 8, this.y + 5);
                    ctx.lineTo(this.x + 14, this.y + this.size - 2);
                    ctx.lineTo(this.x + 8, this.y + this.size - 2); 
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(this.x + 17, this.y + 5);
                    ctx.lineTo(this.x + 23, this.y + this.size - 2);
                    ctx.lineTo(this.x + 17, this.y + this.size - 2); 
                    ctx.closePath();
                    ctx.fill();
                    this.drawHealthBar();
                }
                applyUpgrade() {}
            }
            class Tower extends Entity {
                constructor(x, y) {
                    super(x, y, 'tower', 50, 70);
                    this.range = 5 * GRID_SIZE;
                    this.damage = 1;
                    this.cooldown = 0;
                    this.maxCooldown = 60; 
                    this.target = null;
                }
                draw() {
                    ctx.fillStyle = '#8b4513'; 
                    ctx.fillRect(this.x + 2, this.y + 10, 5, this.size - 10);
                    ctx.fillRect(this.x + this.size - 7, this.y + 10, 5, this.size - 10);
                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 4, this.y + 12); ctx.lineTo(this.x + this.size - 5, this.y + this.size - 2);
                    ctx.moveTo(this.x + 4, this.y + this.size - 2); ctx.lineTo(this.x + this.size - 5, this.y + 12);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                    ctx.fillStyle = COLORS.tower;
                    ctx.fillRect(this.x, this.y + 5, this.size, 8);
                    ctx.fillStyle = '#d62828';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + 5);
                    ctx.lineTo(this.x + this.size / 2, this.y - 5);
                    ctx.lineTo(this.x + this.size, this.y + 5);
                    ctx.closePath();
                    ctx.fill();
                    this.drawHealthBar();
                    if (selectedEntity === this) {
                        ctx.beginPath();
                        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.range, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.stroke();
                    }
                }
                update() {
                    this.findAndShoot();
                }
                findAndShoot() {
                    if (this.cooldown > 0) {
                        this.cooldown--;
                        return;
                    }
                    this.target = findNearestTarget(this, this.range, 'any_enemy'); 
                    if (this.target) {
                        projectiles.push(new Projectile(
                            this.x + this.size / 2, 
                            this.y + this.size / 2, 
                            this.target, 
                            this.damage
                        ));
                        this.cooldown = this.maxCooldown; 
                    }
                }
                applyUpgrade() {
                    this.range += GRID_SIZE; 
                    this.damage *= 2; 
                    this.maxCooldown = Math.max(10, this.maxCooldown - 3); 
                }
            }
            class Shipyard extends Entity {
                constructor(x, y) {
                    super(x, y, 'shipyard', 100, 100);
                    this.warship = null;
                    this.spawnWarship();
                }
                spawnWarship() {
                    const waterNeighbor = findEmptyNeighbor(this.gridX, this.gridY, 4); 
                    if(waterNeighbor) {
                        const ship = new Warship(waterNeighbor.x, waterNeighbor.y, this);
                        this.warship = ship;
                        entities.push(ship);
                        grid[waterNeighbor.y][waterNeighbor.x] = 3; 
                    } else {
                        logMessage("Không tìm thấy mặt nước để đặt Tàu! (Cần ô nước kề bên)");
                    }
                }
                draw() {
                    ctx.fillStyle = COLORS.shipyard;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = '#f1faee';
                    ctx.font = '15px "Press Start 2P"';
                    ctx.fillText("⚓", this.x + 4, this.y + 18);
                    this.drawHealthBar();
                }
                applyUpgrade() {
                    if(this.warship) this.warship.upgrade(); 
                }
                destroy() {
                    super.destroy();
                    if(this.warship) this.warship.destroy();
                }
            }
            class Warship extends Tower { 
                constructor(x, y, shipyard) {
                    super(x, y); 
                    this.type = 'warship';
                    this.shipyard = shipyard; 
                    this.health = 150;
                    this.maxHealth = 150;
                    this.range = 30 * GRID_SIZE; 
                    this.damage = 5;
                    this.maxCooldown = 120; 
                    this.cooldown = 0;
                    this.splashRadius = 0; 
                }
                draw() {
                    if (this.level === 1) {
                        ctx.fillStyle = '#6e442c';
                        ctx.fillRect(this.x, this.y + 5, this.size, this.size - 10);
                        ctx.fillStyle = COLORS.projectile;
                        ctx.fillRect(this.x + 10, this.y - 5, 5, this.size);
                    } else if (this.level === 2) {
                        ctx.fillStyle = '#593b2b'; 
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + 5);
                        ctx.lineTo(this.x + this.size, this.y + 5);
                        ctx.lineTo(this.x + this.size - 4, this.y + this.size - 2);
                        ctx.lineTo(this.x + 4, this.y + this.size - 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = COLORS.projectile;
                        ctx.fillRect(this.x + 10, this.y - 5, 5, this.size);
                        ctx.fillStyle = '#333';
                        ctx.fillRect(this.x + 5, this.y + 10, 5, 5);
                        ctx.fillRect(this.x + 15, this.y + 10, 5, 5);
                    } else {
                        ctx.fillStyle = '#6c757d'; 
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + 8);
                        ctx.lineTo(this.x + this.size, this.y + 8);
                        ctx.lineTo(this.x + this.size - 3, this.y + this.size - 5);
                        ctx.lineTo(this.x + 3, this.y + this.size - 5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#333';
                        ctx.fillRect(this.x + 5, this.y + 5, 15, 5);
                        ctx.fillRect(this.x + 10, this.y, 5, 10);
                        ctx.fillStyle = '#a9a9a9';
                        ctx.fillRect(this.x + 8, this.y + 10, 9, 9);
                    }
                    this.drawHealthBar(); 
                    if (selectedEntity === this.shipyard) {
                        ctx.beginPath();
                        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.range, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.stroke();
                        if (this.splashRadius > 0) {
                            ctx.beginPath();
                            ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.splashRadius * GRID_SIZE, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(214, 40, 40, 0.2)';
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(214, 40, 40, 0.5)';
                            ctx.stroke();
                        }
                    }
                }
                upgrade() {
                    this.level++; 
                    this.range += GRID_SIZE; 
                    this.damage *= 1.5; 
                    this.splashRadius += 0.2; 
                    this.maxHealth += 30;
                    this.health = this.maxHealth;
                    this.maxCooldown = Math.max(30, this.maxCooldown - 15);
                }
                findAndShoot() {
                    if (this.cooldown > 0) {
                        this.cooldown--;
                        return;
                    }
                    this.target = findNearestTarget(this, this.range, 'any_enemy'); 
                    if (this.target) {
                        projectiles.push(new Projectile(
                            this.x + this.size / 2, 
                            this.y + this.size / 2, 
                            this.target, 
                            this.damage,
                            COLORS.projectile,
                            this.splashRadius * GRID_SIZE 
                        ));
                        this.cooldown = this.maxCooldown; 
                    }
                }
                destroy() {
                    super.destroy(); 
                    if(this.shipyard) this.shipyard.warship = null; 
                    if(grid[this.gridY] && grid[this.gridY][this.gridX] === 3) {
                         grid[this.gridY][this.gridX] = 4;
                    }
                }
            }

            // --- Các Lớp Đơn vị (Units) ---
            
            class Unit {
                constructor(x, y, health, baseDamage, speed, type) {
                    this.x = x;
                    this.y = y;
                    this.health = health;
                    this.maxHealth = health;
                    this.baseDamage = baseDamage;
                    this.damage = baseDamage; 
                    this.speed = speed;
                    this.type = type; 
                    this.id = Math.random();
                    this.target = null;
                    this.size = 15;
                    this.attackCooldown = 0;
                    this.weapon = null; 
                }
                draw() {
                    let color = COLORS.enemy;
                    if (this.type === 'soldier') color = COLORS.soldier;
                    else if (this.type === 'orc') color = COLORS.orc;
                    else if (this.type === 'catapult') color = COLORS.catapult;
                    ctx.fillStyle = color;
                    if (this.type !== 'catapult') {
                        ctx.beginPath();
                        ctx.arc(this.x + GRID_SIZE / 2, this.y + GRID_SIZE / 2, this.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillRect(this.x, this.y + 5, this.size, this.size / 2); 
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.x + 5, this.y, 5, this.size); 
                    }
                    if (this.weapon) {
                        ctx.fillStyle = this.weapon.color;
                        ctx.font = '10px "Press Start 2P"';
                        ctx.fillText("†", this.x + 12, this.y + 12); 
                    }
                    const barWidth = this.size + 5;
                    const barHeight = 4;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y - 8, barWidth, barHeight);
                    ctx.fillStyle = (this.type === 'soldier') ? 'green' : 'red';
                    ctx.fillRect(this.x, this.y - 8, barWidth * (this.health / this.maxHealth), barHeight);
                    if (selectedSoldier === this) {
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.x + GRID_SIZE / 2, this.y + GRID_SIZE / 2, this.size / 2 + 3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                    }
                }
                update() {
                    if(this.attackCooldown > 0) this.attackCooldown--;
                    if (!this.target || this.target.health <= 0) {
                        if (this.type !== 'soldier' && this.type !== 'catapult') {
                            this.findTarget();
                        }
                    }
                    if (this.target && this.target.health <= 0) {
                        this.target = null;
                    }
                    if (!this.target) {
                        if(this.type !== 'soldier' && this.type !== 'catapult') {
                            this.moveToCastle();
                        }
                        return; 
                    }
                    const angle = Math.atan2(
                        (this.target.y + (this.target.size || GRID_SIZE) / 2) - (this.y + GRID_SIZE / 2), 
                        (this.target.x + (this.target.size || GRID_SIZE) / 2) - (this.x + GRID_SIZE / 2)
                    );
                    const nextX = this.x + Math.cos(angle) * this.speed;
                    const nextY = this.y + Math.sin(angle) * this.speed;
                    const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                    const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                    const blockingEntity = getEntityAt(nextGridX, nextGridY);
                    let effectiveTarget = this.target; 
                    if (blockingEntity && blockingEntity.type === 'wall' && blockingEntity !== this.target) {
                        effectiveTarget = blockingEntity;
                    }
                    const targetSize = (effectiveTarget.type === 'castle') ? effectiveTarget.size * 0.7 : (effectiveTarget.size || GRID_SIZE) / 2 + 5;
                    const dist = getDistance(this, effectiveTarget);
                    if (dist < targetSize) {
                        this.attack(effectiveTarget); 
                    } else {
                        if (effectiveTarget.type !== 'wall') {
                            this.x = nextX;
                            this.y = nextY;
                        }
                    }
                }
                findTarget() {}
                attack(target) {
                    if (this.attackCooldown === 0 && target) {
                        target.takeDamage(this.damage);
                        this.attackCooldown = 90; 
                        if(this.type.includes('enemy') && target.type === 'castle') {
                             this.destroy();
                        }
                    }
                }
                moveToCastle() {
                    const castle = entities.find(e => e.type === 'castle');
                    if(!castle) return;
                    const angle = Math.atan2(castle.y + castle.size/2 - this.y, castle.x + castle.size/2 - this.x);
                    const nextX = this.x + Math.cos(angle) * this.speed;
                    const nextY = this.y + Math.sin(angle) * this.speed;
                    const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                    const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                    const blockingEntity = getEntityAt(nextGridX, nextGridY);
                    if (blockingEntity && blockingEntity.type === 'wall') {
                        this.target = blockingEntity;
                    } 
                    else if (getDistance(this, castle) < castle.size / 2) {
                        this.target = castle;
                    }
                    else {
                        this.x = nextX;
                        this.y = nextY;
                    }
                }
                takeDamage(amount) {
                    this.health -= amount;
                    if(this.health <= 0) this.destroy();
                }
                destroy() {
                    this.health = 0;
                    if(this.type === 'soldier') {
                        population--;
                        if (selectedSoldier === this) selectedSoldier = null;
                    }
                }
            }
            class Enemy extends Unit {
                constructor(x, y, health, baseDamage, speed, weapon) {
                    super(x, y, health, baseDamage, speed, 'enemy');
                    this.castle = entities.find(e => e.type === 'castle');
                    this.weapon = weapon || getRandomWeapon();
                    this.damage = this.baseDamage * this.weapon.damage; 
                }
                findTarget() {
                    this.target = findNearestTarget(this, 10 * GRID_SIZE, 'soldier');
                    if(this.target) return;
                    const barracks = entities.filter(e => e.type === 'barracks' && e.health > 0);
                    this.target = findNearestEntity(this, barracks, 10 * GRID_SIZE);
                    if(this.target) return;
                    const towers = entities.filter(e => (e.type === 'tower' || e.type === 'warship') && e.health > 0);
                    this.target = findNearestEntity(this, towers, 10 * GRID_SIZE);
                    if(this.target) return;
                    this.target = this.castle;
                }
            }
            class OrcEnemy extends Enemy {
                constructor(x, y) {
                    const baseHealth = (enemyStats.health * 8) + (Math.random() * day * 4);
                    const baseDamage = enemyStats.damage * 5;
                    const baseSpeed = enemyStats.speed * 0.8;
                    super(x, y, baseHealth, baseDamage, baseSpeed, getWeaponByLevel(3)); 
                    this.type = 'orc';
                    this.size = 20; 
                }
            }
            class EnemyCatapult extends Unit {
                constructor(x, y) {
                    const baseHealth = (enemyStats.health * 7) + (Math.random() * day);
                    const baseDamage = enemyStats.damage * 10;
                    const baseSpeed = enemyStats.speed * 0.3;
                    super(x, y, baseHealth, baseDamage, baseSpeed, 'catapult');
                    this.castle = entities.find(e => e.type === 'castle');
                    this.range = 7 * GRID_SIZE; 
                    this.attackCooldown = 0;
                    this.maxCooldown = 240; 
                }
                update() {
                    if (this.attackCooldown > 0) this.attackCooldown--;
                    if (!this.target || this.target.health <= 0) {
                        this.findTarget();
                    }
                    if (this.target && this.target.health <= 0) {
                        this.target = null;
                        this.findTarget(); 
                    }
                    if (!this.target) {
                        this.moveToCastle(); 
                        return;
                    }
                    const dist = getDistance(this, this.target);
                    if (dist < this.range) {
                        this.attack(this.target); 
                    } else {
                        const angle = Math.atan2(
                            (this.target.y + this.target.size / 2) - (this.y + this.size / 2), 
                            (this.target.x + this.target.size / 2) - (this.x + this.size / 2)
                        );
                        const nextX = this.x + Math.cos(angle) * this.speed;
                        const nextY = this.y + Math.sin(angle) * this.speed;
                        const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                        const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                        const blockingEntity = getEntityAt(nextGridX, nextGridY);
                        if (blockingEntity && blockingEntity.type === 'wall') {
                            this.attack(blockingEntity);
                        } else {
                            this.x = nextX;
                            this.y = nextY;
                        }
                    }
                }
                findTarget() {
                    this.target = this.castle;
                    if(getDistance(this, this.castle) < this.range) return;
                    const defenses = entities.filter(e => (e.type === 'tower' || e.type === 'shipyard' || e.type === 'warship') && e.health > 0);
                    this.target = findNearestEntity(this, defenses, this.range * 1.5); 
                    if(this.target) return;
                    const buildings = entities.filter(e => e.type === 'barracks' && e.health > 0);
                    this.target = findNearestEntity(this, buildings, this.range * 1.5);
                    if(this.target) return;
                    this.target = this.castle;
                }
                attack(target) {
                    if (this.attackCooldown === 0 && target) {
                        projectiles.push(new Projectile(
                            this.x + this.size / 2, 
                            this.y + this.size / 2, 
                            target, 
                            this.damage,
                            '#8b4513' 
                        ));
                        this.attackCooldown = this.maxCooldown;
                        if(target.type === 'castle') {
                            target.takeDamage(this.damage * 0.3); 
                        }
                    }
                }
            }
            class Soldier extends Unit {
                constructor(x, y, barracks, baseDamage, weapon) {
                    super(x, y, 20, baseDamage, 0.8, 'soldier');
                    this.barracks = barracks; 
                    this.weapon = weapon;
                    this.damage = this.baseDamage * this.weapon.damage; 
                    this.manualTargetPos = null; 
                }
                findTarget() {
                    this.target = findNearestTarget(this, 15 * GRID_SIZE, 'any_enemy'); 
                }
                update() {
                    if(this.attackCooldown > 0) this.attackCooldown--;
                    if (this.manualTargetPos) {
                        const dist = getDistance(this, this.manualTargetPos, true); 
                        if (dist > this.speed * 2) { 
                            const angle = Math.atan2(this.manualTargetPos.y - (this.y + GRID_SIZE/2), this.manualTargetPos.x - (this.x + GRID_SIZE/2));
                            const nextX = this.x + Math.cos(angle) * this.speed;
                            const nextY = this.y + Math.sin(angle) * this.speed;
                            const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                            const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                            const blockingEntity = getEntityAt(nextGridX, nextGridY);
                            if (blockingEntity && blockingEntity.type === 'wall') {
                                this.manualTargetPos = null;
                            } else {
                                this.x = nextX;
                                this.y = nextY;
                            }
                        } else {
                            this.manualTargetPos = null;
                        }
                        this.findTarget();
                    }
                    if (!this.target || this.target.health <= 0) {
                        this.findTarget();
                    }
                    if (this.target && this.target.health <= 0) {
                        this.target = null;
                    }
                    if (this.target) {
                        this.manualTargetPos = null; 
                        const targetSize = (this.target.size || GRID_SIZE) / 2 + 5;
                        const dist = getDistance(this, this.target);
                        if (dist < targetSize) {
                            this.attack(this.target);
                        } else {
                            const angle = Math.atan2(
                                (this.target.y + this.target.size / 2) - (this.y + this.size / 2), 
                                (this.target.x + this.target.size / 2) - (this.x + this.size / 2)
                            );
                            const nextX = this.x + Math.cos(angle) * this.speed;
                            const nextY = this.y + Math.sin(angle) * this.speed;
                            const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                            const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                            const blockingEntity = getEntityAt(nextGridX, nextGridY);
                            if (!blockingEntity || blockingEntity.type !== 'wall') {
                                this.x = nextX;
                                this.y = nextY;
                            }
                        }
                    } else if (!this.manualTargetPos && this.barracks) {
                        const dist = getDistance(this, this.barracks);
                        if(dist > 5 * GRID_SIZE) { 
                             const angle = Math.atan2(this.barracks.y - this.y, this.barracks.x - this.x);
                             this.x += Math.cos(angle) * (this.speed * 0.5);
                             this.y += Math.sin(angle) * (this.speed * 0.5);
                        }
                    }
                }
            }
            class Projectile {
                constructor(x, y, target, damage, color = COLORS.projectile, splashRadius = 0) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.damage = damage;
                    this.speed = 4;
                    this.size = 5;
                    this.id = Math.random();
                    this.color = color;
                    this.splashRadius = splashRadius; 
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                update() {
                    if (!this.target || this.target.health <= 0) {
                        this.destroy();
                        return;
                    }
                    const targetCenterX = this.target.x + (this.target.size || GRID_SIZE) / 2;
                    const targetCenterY = this.target.y + (this.target.size || GRID_SIZE) / 2;
                    const angle = Math.atan2(targetCenterY - this.y, targetCenterX - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                    const currentGridX = Math.floor(this.x / GRID_SIZE);
                    const currentGridY = Math.floor(this.y / GRID_SIZE);
                    const entityAtPos = getEntityAt(currentGridX, currentGridY);
                    if (entityAtPos && entityAtPos.type === 'wall') {
                        this.applySplashDamage(entityAtPos.x, entityAtPos.y, entityAtPos); 
                        this.destroy();
                        return;
                    }
                    if (getDistance(this, this.target) < (this.target.size || GRID_SIZE) / 2) {
                        this.applySplashDamage(this.target.x, this.target.y, this.target); 
                        this.destroy();
                    }
                }
                applySplashDamage(hitX, hitY, directHitTarget) {
                    directHitTarget.takeDamage(this.damage);
                    if (this.splashRadius > 0) {
                        const splashCenter = { 
                            x: hitX + GRID_SIZE / 2, 
                            y: hitY + GRID_SIZE / 2
                        };
                        units.forEach(unit => {
                            if (unit.type.includes('enemy') || unit.type === 'orc' || unit.type === 'catapult') {
                                if (unit.id === directHitTarget.id) return; 
                                const dist = getDistance(unit, splashCenter, true);
                                if (dist < this.splashRadius) {
                                    unit.takeDamage(this.damage * 0.5); 
                                }
                            }
                        });
                    }
                }
                destroy() {
                    this.damage = 0; 
                }
            }

            // --- Hàm Khởi tạo Game ---
            function init() {
                // (Giữ nguyên logic init, tạo grid, Lâu đài...)
                grid = new Array(ROWS).fill(null).map(() => new Array(COLS).fill(0)); 
                const MID_X = Math.floor(COLS / 2); 
                const MID_Y = Math.floor(ROWS / 2); 
                const lakeStart = {x: 2, y: 15};
                const lakeEnd = {x: 10, y: 22};
                for(let y = lakeStart.y; y < lakeEnd.y; y++) {
                    for(let x = lakeStart.x; x < lakeEnd.x; x++) {
                        grid[y][x] = 4; // 4 = Nước
                    }
                }
                for(let y=0; y < 5; y++) {
                    for(let x=0; x < 5; x++) {
                        if(x+y < 5) {
                            grid[y][x] = 5; // 5 = Đá
                            grid[ROWS-1-y][x] = 5;
                            grid[y][COLS-1-x] = 5;
                            grid[ROWS-1-y][COLS-1-x] = 5;
                        }
                    }
                }
                for(let x = 0; x < COLS; x++) { 
                    grid[MID_Y-1][x] = (grid[MID_Y-1][x] === 0 || grid[MID_Y-1][x] === 1) ? 1 : grid[MID_Y-1][x];
                    grid[MID_Y][x] = (grid[MID_Y][x] === 0 || grid[MID_Y][x] === 1) ? 1 : grid[MID_Y][x];
                }
                for(let y = 0; y < ROWS; y++) { 
                    grid[y][MID_X-1] = (grid[y][MID_X-1] === 0 || grid[y][MID_X-1] === 1) ? 1 : grid[y][MID_X-1];
                    grid[y][MID_X] = (grid[y][MID_X] === 0 || grid[y][MID_X] === 1) ? 1 : grid[y][MID_X];
                }
                const castle = new Castle(MID_X-1, MID_Y-1);
                entities.push(castle);
                grid[MID_Y-1][MID_X-1] = 2; 
                grid[MID_Y-1][MID_X] = 2;
                grid[MID_Y][MID_X-1] = 2;
                grid[MID_Y][MID_X] = 2;
                maxCastleHealth = castle.maxHealth;
                castleHealth = castle.health;
                castleLevel = castle.level;

                setupEventListeners();
                updateShopUI();
                gameLoop(0);
            }

            // --- Vòng lặp Game ---
            // (Giữ nguyên gameLoop, update, startNewDay, collectTaxes, spawnEnemiesOnce)
            let lastTime = 0;
            function gameLoop(currentTime) {
                if (gameOver) {
                    drawGameOver();
                    return;
                }
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                if(!deltaTime) { 
                    requestAnimationFrame(gameLoop);
                    return;
                }
                gameTime += deltaTime;
                dayTimerDisplay = (DAY_LENGTH_MS - gameTime) / 1000;
                isNight = (gameTime / DAY_LENGTH_MS) > NIGHT_START_RATIO;
                if (gameTime >= DAY_LENGTH_MS) {
                    gameTime = 0;
                    startNewDay();
                }
                update(deltaTime);
                draw();
                updateUI();
                requestAnimationFrame(gameLoop);
            }
            function update(deltaTime) {
                entities.forEach(e => e.update());
                units.forEach(u => u.update());
                projectiles.forEach(p => p.update());
                if (isNight && !hasSpawnedTonight && day > 1) {
                    spawnEnemiesOnce();
                }
                entities = entities.filter(e => e.health > 0);
                units = units.filter(u => u.health > 0);
                projectiles = projectiles.filter(p => p.damage > 0);
            }

            // --- Logic Vẽ (Draw) ---
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        let color = COLORS.grass;
                        if (grid[y][x] === 1) color = COLORS.path;
                        else if (grid[y][x] === 4) color = COLORS.water;
                        else if (grid[y][x] === 5) color = COLORS.rock;
                        else if (grid[y][x] === 6) color = COLORS.path; 
                        ctx.fillStyle = color;
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        if (grid[y][x] !== 0 && grid[y][x] !== 2 && grid[y][x] !== 3 && grid[y][x] !== 5) {
                            // --- SỬA LỖI ĐỒ HỌA MOBILE ---
                            // Đã xóa phần vẽ cỏ mờ (gây lag trên mobile)
                            // --- KẾT THÚC SỬA LỖI ---
                        }
                    }
                }
                entities.forEach(e => e.draw());
                units.forEach(u => u.draw());
                projectiles.forEach(p => p.draw());
                drawDayNightCycle();
                if (selectedShopItem) {
                    drawPlacementPreview();
                }
                if (selectedSoldier && selectedSoldier.manualTargetPos) {
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = '15px "Press Start 2P"';
                    ctx.fillText("⚑", selectedSoldier.manualTargetPos.x - 8, selectedSoldier.manualTargetPos.y + 5);
                }
            }
            function drawDayNightCycle() {
                let opacity = 0;
                const nightTime = DAY_LENGTH_MS * (1 - NIGHT_START_RATIO); 
                const dayTime = DAY_LENGTH_MS * NIGHT_START_RATIO; 
                if (isNight) {
                    opacity = Math.min(0.6, (gameTime - dayTime) / (nightTime / 2) * 0.6);
                } else {
                    if(gameTime > dayTime - nightTime / 2) {
                        opacity = (gameTime - (dayTime - nightTime / 2)) / (nightTime / 2) * 0.6;
                    }
                }
                if (opacity > 0) {
                    ctx.fillStyle = `rgba(0, 0, 50, ${opacity})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
            function drawPlacementPreview() {
                const x = mousePos.gridX;
                const y = mousePos.gridY;
                const size = GRID_SIZE;
                let canPlace = canBuildAt(selectedShopItem.type, x, y);
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = canPlace ? 'green' : 'red';
                ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, size, size);
                ctx.globalAlpha = 1.0;
            }
            function drawGameOver() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'red';
                ctx.font = '30px var(--font-family)';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                ctx.fillStyle = 'white';
                ctx.font = '14px var(--font-family)';
                ctx.fillText('Bạn trụ được ' + (day - 1) + ' ngày', canvas.width / 2, canvas.height / 2 + 20);
                ctx.font = '10px var(--font-family)';
                ctx.fillText('Nhấn F5 để chơi lại', canvas.width / 2, canvas.height / 2 + 50);
            }

            // --- Cập nhật UI ---
            // (Giữ nguyên updateUI, updateShopUI, showUpgradePanel, hideUpgradePanel)
            function updateUI() {
                moneyDisplay.textContent = `Tiền: ${Math.floor(money)}$`;
                dayDisplay.textContent = `Ngày: ${day} (${isNight ? 'Đêm' : 'Ngày'} ${Math.ceil(dayTimerDisplay)}s) | Lv: ${castleLevel}`; 
                castleHealthDisplay.textContent = `Lâu Đài: ${Math.floor(castleHealth)}/${maxCastleHealth} HP`;
                populationDisplay.textContent = `Lính: ${population}`;
                updateShopUI(); 
            }
            function updateShopUI() {
                shopItems.forEach(item => {
                    const cost = parseInt(item.dataset.cost);
                    if (money < cost) {
                        item.classList.add('disabled');
                    } else {
                        item.classList.remove('disabled');
                    }
                    if(item.dataset.type === 'clinic') {
                        const clinicCount = entities.filter(e => e.type === 'clinic').length;
                        if(clinicCount >= 3) { 
                            item.classList.add('disabled');
                            item.querySelector('.cost').textContent = "Tối đa: 3";
                        } else {
                            item.querySelector('.cost').textContent = `Giá: ${cost}$`;
                        }
                    }
                });
            }
            function showUpgradePanel(entity) {
                selectedEntity = entity;
                selectedSoldier = null; 
                upgradePanel.style.display = 'block';
                upgradeTitle.textContent = `${entity.type === 'castle' ? 'Lâu Đài' : entity.type} (Cấp ${entity.level})`;
                upgradeHealth.textContent = `Máu: ${Math.floor(entity.health)}/${entity.maxHealth}`;
                let info = "";
                if(entity.income) info = `Thu nhập: ${entity.income}$/ngày`;
                if(entity.type === 'farmplot') info = `Buff Thuế: +${Math.round(entity.buffBonus * 100)}%`;
                if(entity.type === 'clinic') info = `Hồi: ${entity.level} lính/đêm (toàn cục)`;
                if(entity.type === 'tower') info = `Tầm: ${entity.range/GRID_SIZE} - Thiệt hại: ${entity.damage} - Tốc độ: ${(entity.maxCooldown / 60).toFixed(2)}s`;
                if(entity.type === 'barracks') {
                    const nextWeaponLevel = Math.min(entity.level + 1, WEAPONS.length);
                    info = `Tối đa: ${entity.maxSoldiers} Lính. Vũ khí: ${getWeaponByLevel(entity.currentWeaponLevel).name}. ${entity.level < 4 ? `(Lên cấp ${nextWeaponLevel} đổi sang ${getWeaponByLevel(nextWeaponLevel).name})` : ''}`;
                }
                if(entity.type === 'shipyard') info = `Nâng cấp Tàu Chiến (Lv ${entity.warship ? entity.warship.level : 1})`;
                if(entity.type === 'warship') info = `Tàu Chiến Lv ${entity.level} - Dmg: ${entity.damage.toFixed(1)} - Splash: ${(entity.splashRadius * GRID_SIZE).toFixed(0)}px`;
                if(entity.type === 'wall') info = `(Chỉ tăng máu)`;
                if(entity.type === 'castle') info = `(Nâng cấp hồi full máu)`;
                upgradeInfo.textContent = info;
                if (entity.level < 10 || entity.type === 'castle') { 
                    const cost = entity.getUpgradeCost();
                    upgradeButton.textContent = `Nâng Cấp (${cost}$)`;
                    upgradeButton.disabled = money < cost;
                } else {
                    upgradeButton.textContent = "Đã Tối Đa";
                    upgradeButton.disabled = true;
                }
                if(entity.type === 'castle') {
                    sellButton.style.display = 'none';
                } else {
                    sellButton.style.display = 'block';
                    const sellValue = entity.getSellValue();
                    sellButton.textContent = `Bán (${sellValue}$)`;
                }
            }
            function hideUpgradePanel() {
                selectedEntity = null;
                upgradePanel.style.display = 'none';
            }

            // --- Logic Ngày mới ---
            // (Giữ nguyên startNewDay, collectTaxes, spawnEnemiesOnce)
            function startNewDay() {
                day++;
                isNight = false;
                hasSpawnedTonight = false; 
                logMessage(`Ngày ${day} bắt đầu!`);
                collectTaxes();
                let totalSoldiersToSpawn = 0;
                entities.filter(e => e.type === 'clinic').forEach(clinic => {
                    totalSoldiersToSpawn += clinic.level;
                });
                if (totalSoldiersToSpawn > 0) {
                    let spawned = 0;
                    const barracksList = entities.filter(e => e.type === 'barracks');
                    for(const b of barracksList) {
                        if (spawned >= totalSoldiersToSpawn) break; 
                        while(b.soldiers.length < b.maxSoldiers && spawned < totalSoldiersToSpawn) {
                            const spawnPos = findEmptyNeighbor(b.gridX, b.gridY);
                            if (spawnPos) {
                                const weapon = getWeaponByLevel(b.currentWeaponLevel);
                                const newSoldier = new Soldier(
                                    spawnPos.x * GRID_SIZE,
                                    spawnPos.y * GRID_SIZE,
                                    b, b.soldierBaseDamage, weapon
                                );
                                units.push(newSoldier);
                                b.soldiers.push(newSoldier);
                                population++;
                                spawned++;
                            } else {
                                break; 
                            }
                        }
                    }
                    if (spawned > 0) {
                        logMessage(`Bệnh xá đã đào tạo ${spawned} lính mới!`);
                    }
                }
                if (day > 1) {
                    enemyStats.spawnCount = 3 + 3 * (day - 1);
                    enemyStats.health = 5 + 2 * (day - 1);
                    enemyStats.damage = 2 + 0.5 * (day - 1);
                }
            }
            function collectTaxes() {
                let totalIncome = 10; 
                let buffMultiplier = 1.0; 
                entities.filter(e => e.type === 'farmplot').forEach(plot => {
                    buffMultiplier += plot.buffBonus; 
                });
                entities.forEach(e => {
                    if (e.income) {
                        let income = e.income;
                        if(e.type === 'house' || e.type === 'farm') {
                             totalIncome += income * buffMultiplier;
                        } else {
                             totalIncome += income;
                        }
                    }
                });
                money += Math.floor(totalIncome);
                logMessage(`Đã nhận ${Math.floor(totalIncome)}$ thuế. (Hệ số: ${buffMultiplier.toFixed(1)}x)`);
            }
            function spawnEnemiesOnce() {
                hasSpawnedTonight = true; 
                logMessage(`Cảnh báo! Kẻ thù đang tấn công!`);
                let totalCount = enemyStats.spawnCount;
                const spawnCounts = [0, 0, 0, 0];
                for(let i=0; i < totalCount; i++) {
                    spawnCounts[i % 4]++;
                }
                for(let side = 0; side < 4; side++) {
                    const count = spawnCounts[side];
                    if (count === 0) continue;
                    let spawnZone;
                    if(side === 0) spawnZone = { x: [MID_X-1, MID_X], y: [0, 0] }; 
                    else if(side === 1) spawnZone = { x: [MID_X-1, MID_X], y: [ROWS - 1, ROWS - 1] }; 
                    else if(side === 2) spawnZone = { x: [0, 0], y: [MID_Y-1, MID_Y] }; 
                    else spawnZone = { x: [COLS - 1, COLS - 1], y: [MID_Y-1, MID_Y] }; 
                    for (let i = 0; i < count; i++) {
                        const gridX = spawnZone.x[Math.floor(Math.random() * spawnZone.x.length)];
                        const gridY = spawnZone.y[Math.floor(Math.random() * spawnZone.y.length)];
                        const weapon = getRandomWeapon();
                        units.push(new Enemy(
                            gridX * GRID_SIZE, gridY * GRID_SIZE, 
                            enemyStats.health + (Math.random() * day), 
                            enemyStats.damage, enemyStats.speed, weapon
                        ));
                    }
                }
                if (day >= 6) {
                    const orcPerSide = Math.floor((day - 4) / 2);
                    if (orcPerSide > 0) {
                        for (let side = 0; side < 4; side++) {
                            for (let k = 0; k < orcPerSide; k++) {
                                let spawnZone;
                                if(side === 0) spawnZone = { x: [MID_X-1, MID_X], y: [0, 0] }; 
                                else if(side === 1) spawnZone = { x: [MID_X-1, MID_X], y: [ROWS - 1, ROWS - 1] }; 
                                else if(side === 2) spawnZone = { x: [0, 0], y: [MID_Y-1, MID_Y] }; 
                                else spawnZone = { x: [COLS - 1, COLS - 1], y: [MID_Y-1, MID_Y] }; 
                                const gridX = spawnZone.x[Math.floor(Math.random() * spawnZone.x.length)];
                                const gridY = spawnZone.y[Math.floor(Math.random() * spawnZone.y.length)];
                                units.push(new OrcEnemy(gridX * GRID_SIZE, gridY * GRID_SIZE));
                            }
                        }
                        logMessage(`ORC đã xuất hiện! (${orcPerSide} mỗi hướng)`);
                    }
                }
                if (day >= 10) {
                    const catapultCount = Math.floor((day - 5) / 5);
                    for (let c = 0; c < catapultCount; c++) {
                        const side = Math.floor(Math.random() * 4);
                        let spawnZone;
                        if(side === 0) spawnZone = { x: [MID_X-1, MID_X], y: [0, 0] }; 
                        else if(side === 1) spawnZone = { x: [MID_X-1, MID_X], y: [ROWS - 1, ROWS - 1] };
                        else if(side === 2) spawnZone = { x: [0, 0], y: [MID_Y-1, MID_Y] };
                        else spawnZone = { x: [COLS - 1, COLS - 1], y: [MID_Y-1, MID_Y] };
                        const gridX = spawnZone.x[Math.floor(Math.random() * spawnZone.x.length)];
                        const gridY = spawnZone.y[Math.floor(Math.random() * spawnZone.y.length)];
                        units.push(new EnemyCatapult(gridX * GRID_SIZE, gridY * GRID_SIZE));
                    }
                    if (catapultCount > 0) logMessage(`Máy bắn đá của địch: ${catapultCount}!`);
                }
            }

            // --- Xử lý Sự kiện (Events) ---
            function setupEventListeners() {
                // Chọn item trong shop
                shopItems.forEach(item => {
                    item.addEventListener('click', () => {
                        if(item.classList.contains('disabled')) return;
                        
                        hideUpgradePanel();
                        selectedSoldier = null; 
                        shopItems.forEach(i => i.classList.remove('selected'));
                        
                        selectedShopItem = {
                            type: item.dataset.type,
                            cost: parseInt(item.dataset.cost)
                        };
                        item.classList.add('selected');
                        logMessage(`Đã chọn: ${selectedShopItem.type}. (Tap để hủy)`);
                    });
                });

                // --- THAY ĐỔI: Hỗ trợ Cảm ứng ---
                // Hàm helper để cập nhật mousePos từ touch/mouse
                function updateMousePos(e) {
                    const rect = canvas.getBoundingClientRect();
                    let clientX, clientY;
                    
                    if (e.touches && e.touches.length > 0) {
                        // Dùng touch event
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        // Dùng mouse event
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    // Tính toán tọa độ trên canvas (đã scale)
                    // (600 là width/height gốc của canvas nội bộ)
                    mousePos.x = (clientX - rect.left) * (600 / rect.width);
                    mousePos.y = (clientY - rect.top) * (600 / rect.height);
                    mousePos.gridX = Math.floor(mousePos.x / GRID_SIZE);
                    mousePos.gridY = Math.floor(mousePos.y / GRID_SIZE);
                    
                    // Ngăn trang cuộn khi chạm vào canvas
                    if (e.type === 'touchmove') {
                        e.preventDefault();
                    }
                }

                // Cập nhật vị trí chuột/chạm
                canvas.addEventListener('mousemove', updateMousePos);
                canvas.addEventListener('touchstart', updateMousePos, { passive: false });
                canvas.addEventListener('touchmove', updateMousePos, { passive: false });

                // --- THAY ĐỔI: Xóa Click Phải ---
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // Vẫn giữ để chặn menu chuột phải
                });

                // --- THAY ĐỔI: Logic Click/Tap mới ---
                canvas.addEventListener('click', () => {
                    const x = mousePos.gridX;
                    const y = mousePos.gridY;
                    
                    // Ưu tiên 1: Di chuyển lính (nếu lính đang được chọn)
                    if (selectedSoldier) {
                        const soldierAtClick = getSoldierAt(mousePos.x, mousePos.y);
                        const entityAtClick = getEntityAt(x, y);

                        if (!soldierAtClick && !entityAtClick) { 
                            // Click vào NỀN ĐẤT TRỐNG -> Ra lệnh di chuyển
                            selectedSoldier.manualTargetPos = { x: mousePos.x, y: mousePos.y };
                            selectedSoldier.target = null;
                            logMessage("Lính đã nhận lệnh di chuyển!");
                            selectedSoldier = null; // Bỏ chọn sau khi ra lệnh
                        } else if (soldierAtClick && soldierAtClick.id === selectedSoldier.id) {
                            // Click lại vào lính đang chọn -> Bỏ chọn
                            selectedSoldier = null;
                        } else if (soldierAtClick) {
                            // Click vào lính khác -> Đổi lính
                            selectedSoldier = soldierAtClick;
                            logMessage("Đã chọn lính! (Tap đất trống để di chuyển)");
                        } else if (entityAtClick) {
                            // Click vào công trình -> Bỏ chọn lính, chọn công trình
                            selectEntityForUpgrade(entityAtClick);
                        }
                        return; // Kết thúc
                    }
                    
                    // Ưu tiên 2: Xây dựng (nếu đang chọn shop)
                    if (selectedShopItem) {
                        buildEntity(x, y);
                        return; // Kết thúc
                    }
                    
                    // Ưu tiên 3: Chọn (lính hoặc công trình)
                    const soldier = getSoldierAt(mousePos.x, mousePos.y);
                    if (soldier) {
                        selectedSoldier = soldier;
                        selectedEntity = null;
                        hideUpgradePanel();
                        logMessage("Đã chọn lính! (Tap đất trống để di chuyển)");
                    } else {
                        const entity = getEntityAt(x, y);
                        if(entity && (entity.type !== 'warship')) { 
                            selectEntityForUpgrade(entity);
                        } else if (entity && entity.type === 'warship') {
                            selectEntityForUpgrade(entity.shipyard);
                        }
                        else {
                            // Click vào nền đất trống (không có gì được chọn)
                            hideUpgradePanel();
                            selectedSoldier = null; 
                        }
                    }
                });
                
                // (Giữ nguyên listener của Nâng cấp & Bán)
                upgradeButton.addEventListener('click', () => {
                    if(selectedEntity) {
                        selectedEntity.upgrade();
                        if(selectedEntity.type === 'castle') {
                            maxCastleHealth = selectedEntity.maxHealth;
                            castleHealth = selectedEntity.health;
                            castleLevel = selectedEntity.level;
                        }
                        if (selectedEntity.type === 'shipyard') {
                            showUpgradePanel(selectedEntity.warship); 
                            selectedEntity = selectedEntity; 
                        }
                    }
                });
                
                sellButton.addEventListener('click', () => {
                    if(selectedEntity) {
                        const sellValue = selectedEntity.getSellValue();
                        money += sellValue;
                        logMessage(`Đã bán ${selectedEntity.type} thu về ${sellValue}$`);
                        selectedEntity.destroy();
                        hideUpgradePanel();
                    }
                });
            }
            
            // --- (Giữ nguyên các hàm buildEntity, canBuildAt, findEmptyNeighbor, v.v.) ---
            function buildEntity(x, y) {
                if (!canBuildAt(selectedShopItem.type, x, y)) {
                    logMessage("Không thể xây ở đây!");
                    return;
                }
                if (money < selectedShopItem.cost) {
                    logMessage("Không đủ tiền!");
                    return;
                }
                money -= selectedShopItem.cost;
                const oldGridValue = grid[y][x];
                let newEntity;
                switch(selectedShopItem.type) {
                    case 'house': newEntity = new House(x, y, 'house', 10, 30, 3); break;
                    case 'farm': newEntity = new House(x, y, 'farm', 20, 40, 5); break;
                    case 'farmplot': newEntity = new FarmPlot(x, y); break;
                    case 'clinic': newEntity = new Clinic(x, y); break;
                    case 'barracks': newEntity = new Barracks(x, y); break;
                    case 'wall':
                        newEntity = new Wall(x, y); 
                        if (oldGridValue === 1) grid[y][x] = 6; 
                        else grid[y][x] = 3; 
                        break;
                    case 'tower': newEntity = new Tower(x, y); break;
                    case 'shipyard':
                        newEntity = new Shipyard(x, y);
                        grid[y][x] = 3; 
                        break;
                }
                if(newEntity && newEntity.type !== 'wall' && newEntity.type !== 'shipyard') {
                    grid[y][x] = 3; 
                }
                if(newEntity) {
                    entities.push(newEntity);
                    logMessage(`Đã xây ${selectedShopItem.type}!`);
                }
                selectedShopItem = null;
                shopItems.forEach(i => i.classList.remove('selected'));
            }
            function canBuildAt(type, x, y) {
                if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
                const gridValue = grid[y][x];
                if (gridValue === 2 || gridValue === 3 || gridValue === 5 || gridValue === 6) return false; 
                if(type === 'clinic') {
                    const clinicCount = entities.filter(e => e.type === 'clinic').length;
                    if(clinicCount >= 3) {
                        logMessage("Đã đạt giới hạn 3 Bệnh xá!");
                        return false;
                    }
                }
                if(type === 'wall') {
                    return gridValue === 0 || gridValue === 1;
                }
                if(type === 'shipyard') {
                    return gridValue === 0 && (
                        (y > 0 && grid[y-1][x] === 4) ||
                        (y < ROWS - 1 && grid[y+1][x] === 4) ||
                        (x > 0 && grid[y][x-1] === 4) ||
                        (x < COLS - 1 && grid[y][x+1] === 4)
                    );
                }
                return gridValue === 0;
            }
            function findEmptyNeighbor(x, y, type = 0) { 
                 const neighbors = [
                    {x: x, y: y - 1}, {x: x, y: y + 1},
                    {x: x - 1, y: y}, {x: x + 1, y: y},
                    {x: x - 1, y: y - 1}, {x: x + 1, y: y - 1},
                    {x: x - 1, y: y + 1}, {x: x + 1, y: y + 1}
                ];
                for (const n of neighbors) {
                    if(n.x >= 0 && n.x < COLS && n.y >= 0 && n.y < ROWS) {
                        if(grid[n.y][n.x] === type) {
                            return n;
                        }
                    }
                }
                return null;
            }
            function getDistance(obj1, obj2, isPoint = false) {
                const obj1_centerX = obj1.x + (obj1.size || GRID_SIZE) / 2;
                const obj1_centerY = obj1.y + (obj1.size || GRID_SIZE) / 2;
                let obj2_centerX, obj2_centerY;
                if (isPoint) {
                    obj2_centerX = obj2.x; 
                    obj2_centerY = obj2.y;
                } else {
                    obj2_centerX = obj2.x + (obj2.size || GRID_SIZE) / 2;
                    obj2_centerY = obj2.y + (obj2.size || GRID_SIZE) / 2;
                }
                const dx = obj1_centerX - obj2_centerX;
                const dy = obj1_centerY - obj2_centerY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            function findNearestTarget(source, range, targetType) {
                let nearest = null;
                let minDist = range;
                let targets = [];
                if (targetType === 'soldier') {
                    targets = units.filter(u => u.type === 'soldier' && u.health > 0);
                } else if (targetType === 'enemy') {
                    targets = units.filter(u => u.type === 'enemy' && u.health > 0);
                } else if (targetType === 'any_enemy') {
                    targets = units.filter(u => (u.type.includes('enemy') || u.type === 'orc' || u.type === 'catapult') && u.health > 0);
                }
                for (const target of targets) {
                    if (target.health <= 0) continue; 
                    const dist = getDistance(source, target);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = target;
                    }
                }
                return nearest;
            }
            function findNearestEntity(source, targets, range) {
                let nearest = null;
                let minDist = range;
                for (const target of targets) {
                    if (target.health <= 0) continue;
                    const dist = getDistance(source, target);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = target;
                    }
                }
                return nearest;
            }
            function getEntityAt(gridX, gridY) {
                if (gridX >= MID_X - 1 && gridX <= MID_X && gridY >= MID_Y - 1 && gridY <= MID_Y) {
                    return entities.find(e => e.type === 'castle');
                }
                return entities.find(e => {
                    return e.gridX === gridX && e.gridY === gridY;
                });
            }
            function getSoldierAt(pixelX, pixelY) {
                for (const soldier of units) {
                    if (soldier.type !== 'soldier' || soldier.health <= 0) continue;
                    const centerX = soldier.x + GRID_SIZE / 2;
                    const centerY = soldier.y + GRID_SIZE / 2;
                    const radius = soldier.size / 2;
                    const dx = pixelX - centerX;
                    const dy = pixelY - centerY;
                    if (Math.sqrt(dx * dx + dy * dy) < radius) {
                        return soldier;
                    }
                }
                return null;
            }
            function selectEntityForUpgrade(entity) {
                if(entity) {
                    if (entity.type === 'shipyard' && entity.warship) {
                        showUpgradePanel(entity.warship);
                        selectedEntity = entity; 
                    } 
                    else if (entity.type === 'warship') {
                        showUpgradePanel(entity);
                        selectedEntity = entity.shipyard; 
                    }
                    else {
                        showUpgradePanel(entity);
                    }
                    selectedShopItem = null;
                    selectedSoldier = null; 
                    shopItems.forEach(i => i.classList.remove('selected'));
                }
            }
            function logMessage(msg) {
                messageDisplay.textContent = msg;
            }
            
            // --- Bắt đầu Game ---
            init();
        });
    </script>
</body>
</html>