<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The King - Sửa Lỗi Tường</title> <!-- Đổi Title -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* CSS cho Game (Giữ nguyên) */
        :root {
            --grid-size: 25px; /* Kích thước ô nhỏ hơn để vừa nhiều thứ */
            --font-family: 'Press Start 2P', cursive;
            --font-size-small: 8px;
            --font-size-base: 10px;
            --font-size-header: 14px;
            
            /* Màu sắc */
            --color-grass: #2a9d8f;
            --color-path: #8d6e63;
            --color-water: #4a90e2;
            --color-rock: #6c757d;
            --color-castle: #a8dadc;
            --color-ui-bg: #264653;
            --color-ui-border: #1e3a47;
            --color-font-main: #e9c46a;
            --color-font-light: #f1faee;
            --color-font-danger: #e63946;
            
            /* Màu Công trình */
            --color-house: #f4a261;
            --color-farm: #b5835a; 
            --color-farmplot: #e9c46a; 
            --color-clinic: #f1faee;
            --color-barracks: #cd853f; 
            --color-wall: #c9ada7;
            --color-tower: #e76f51; 
            --color-shipyard: #457b9d; 
            
            /* Màu Đơn vị */
            --color-enemy: #d62828;
            --color-orc: #228b22; 
            --color-catapult: #593b2b; 
            --color-soldier: #0077b6;
            --color-projectile: #f1faee;
        }

        body {
            font-family: var(--font-family);
            background-color: #1a1a1a;
            color: var(--color-font-main);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-size: var(--font-size-base);
        }

        /* Container chính của game */
        #game-container {
            display: flex;
            border: 4px solid var(--color-ui-bg);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: var(--color-ui-bg);
        }

        /* Giao diện người dùng (Shop, Thông tin) */
        #ui-panel {
            width: 220px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            background-color: var(--color-ui-bg);
            border-right: 4px solid var(--color-ui-border);
            color: var(--color-font-light);
            font-size: var(--font-size-small); /* Chữ nhỏ hơn cho UI */
        }

        /* Bảng thông số game */
        #game-stats {
            width: 100%;
            border-bottom: 2px solid var(--color-font-main);
            padding-bottom: 10px;
            margin-bottom: 10px;
            /* Đặt tiền bên phải */
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        #game-stats div {
            font-size: var(--font-size-base);
            color: var(--color-font-main);
            width: 100%;
        }
        #money-display {
            text-align: right;
            color: #f1c40f; /* Vàng sáng cho tiền */
        }

        h2 {
            font-size: var(--font-size-header);
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--color-font-main);
            border-bottom: 2px solid var(--color-font-main);
            padding-bottom: 5px;
        }

        /* Cửa hàng */
        #shop {
            display: grid;
            grid-template-columns: 1fr 1fr; /* 2 cột */
            gap: 8px;
            margin-bottom: 15px;
        }

        .shop-item {
            padding: 8px 5px;
            background-color: #457b9d;
            color: var(--color-font-light);
            text-align: center;
            cursor: pointer;
            border-radius: 5px;
            border: 2px solid #a8dadc;
            transition: background-color 0.2s, transform 0.2s;
            line-height: 1.3;
        }

        .shop-item:hover {
            background-color: #1d3557;
            transform: scale(1.05);
        }

        .shop-item.selected {
            background-color: var(--color-font-danger);
            border-color: var(--color-font-light);
        }
        
        .shop-item.disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .cost {
            font-size: 7px;
            color: #f1c40f;
            display: block;
            margin-top: 2px;
        }

        /* Bảng Nâng cấp */
        #upgrade-panel {
            border-top: 2px solid var(--color-font-main);
            padding-top: 10px;
            margin-top: auto; /* Đẩy xuống dưới cùng */
            display: none; /* Ẩn mặc định */
        }
        
        #upgrade-panel h3 {
            font-size: var(--font-size-base);
            margin: 0 0 5px 0;
            color: var(--color-font-main);
            text-align: center;
        }
        
        #upgrade-stats {
            font-size: var(--font-size-small);
            line-height: 1.4;
            margin-bottom: 10px;
        }

        #upgrade-button {
            width: 100%;
            padding: 10px;
            background-color: #38a3a5;
            color: var(--color-font-light);
            border: none;
            border-radius: 5px;
            font-family: var(--font-family);
            font-size: var(--font-size-base);
            cursor: pointer;
        }
        
        #upgrade-button:hover {
            background-color: #2a9d8f;
        }
        
        #upgrade-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        #sell-button {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: var(--color-font-danger);
            color: var(--color-font-light);
            border: none;
            border-radius: 5px;
            font-family: var(--font-family);
            font-size: var(--font-size-small);
            cursor: pointer;
        }

        /* Thông báo */
        #message-display {
            font-size: 9px;
            height: 30px;
            border-top: 2px solid var(--color-font-main);
            padding-top: 10px;
            margin-top: 10px;
            color: var(--color-font-danger);
            text-align: center;
            line-height: 1.3;
        }

        /* Màn hình Game */
        #game-canvas {
            background-color: var(--color-grass);
            cursor: crosshair;
            /* Tắt làm mịn ảnh để giữ hiệu ứng pixel */
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="ui-panel">
            
            <div id="game-stats">
                <div id="day-display">Ngày: 1</div>
                <div id="money-display">Tiền: 100$</div>
                <div id="castle-health-display">Lâu Đài: 100 HP</div>
                <div id="population-display">Lính: 0</div>
            </div>

            <h2>Cửa Hàng</h2>
            <div id="shop">
                <div class="shop-item" data-type="house" data-cost="10">
                    Nhà Nhỏ (+3$/ngày)
                    <span class="cost">Giá: 10$</span>
                </div>
                <div class="shop-item" data-type="farm" data-cost="15">
                    Nhà Gia Súc (+5$/ngày)
                    <span class="cost">Giá: 15$</span>
                </div>
                <div class="shop-item" data-type="farmplot" data-cost="10">
                    Ruộng Vàng (+10% Thuế)
                    <span class="cost">Giá: 10$</span>
                </div>
                <div class="shop-item" data-type="clinic" data-cost="15">
                    Bệnh Xá (+1 lính/đêm/Lv)
                    <span class="cost">Giá: 20$</span>
                </div>
                <div class="shop-item" data-type="barracks" data-cost="30">
                    Túp Lều (Kiếm Gỗ - 5 Lính)
                    <span class="cost">Giá: 30$</span>
                </div>
                <div class="shop-item" data-type="wall" data-cost="5">
                    Hàng Rào (HP Cao)
                    <span class="cost">Giá: 5$</span>
                </div>
                <div class="shop-item" data-type="tower" data-cost="30">
                    Tháp Canh (Tầm: 5)
                    <span class="cost">Giá: 30$</span>
                </div>
                <div class="shop-item" data-type="shipyard" data-cost="50">
                    Xưởng Tàu (Tầm: 30)
                    <span class="cost">Giá: 50$</span>
                </div>
            </div>
            
            <div id="message-display">Chào mừng, Nhà Vua! (Click lính để chọn, Click phải để di chuyển)</div>
            
            <div id="upgrade-panel">
                <h3 id="upgrade-title">Nâng Cấp</h3>
                <div id="upgrade-stats">
                    <div id="upgrade-level">Level: 1</div>
                    <div id="upgrade-health">Máu: 50/50</div>
                    <div id="upgrade-info"></div>
                </div>
                <button id="upgrade-button">Nâng Cấp (5$)</button>
                <button id="sell-button">Bán (5$)</button>
            </div>
        </div>
        
        <canvas id="game-canvas" width="600" height="600"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- Cài đặt Game ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false; // Tắt làm mịn ảnh

            // Bảng màu JS (Đồng bộ với CSS variables) - Dùng để vẽ trên Canvas
            const COLORS = {
                grass: '#2a9d8f', path: '#8d6e63', water: '#4a90e2', rock: '#6c757d',
                castle: '#a8dadc', house: '#f4a261', 
                farm: '#b5835a', // Farm (Nhà gia súc)
                farmplot: '#e9c46a', // FarmPlot (Ruộng vàng)
                clinic: '#f1faee', // Bệnh xá
                barracks: '#cd853f', // Barracks (Túp lều)
                wall: '#c9ada7', 
                tower: '#e76f51', // Tháp canh
                shipyard: '#457b9d', 
                enemy: '#d62828', // Quái đỏ
                orc: '#228b22', // Orc
                catapult: '#593b2b', // Máy bắn đá
                soldier: '#0077b6', 
                projectile: '#f1faee'
            };
            
            // --- Hệ thống Vũ khí ---
            const WEAPONS = [
                { name: 'Kiếm Gỗ', damage: 2, color: '#8b4513' },
                { name: 'Kiếm Đá', damage: 4, color: '#a9a9a9' },
                { name: 'Kiếm Sắt', damage: 12, color: '#cccccc' },
                { name: 'Kiếm Kim Cương', damage: 16, color: '#33ccff' }
            ];
            const getWeaponByLevel = (level) => {
                return WEAPONS[Math.min(level - 1, WEAPONS.length - 1)];
            };
            const getRandomWeapon = () => {
                return WEAPONS[Math.floor(Math.random() * WEAPONS.length)];
            };


            const GRID_SIZE = 25;
            const COLS = canvas.width / GRID_SIZE; // 24
            const ROWS = canvas.height / GRID_SIZE; // 24
            const MID_X = Math.floor(COLS / 2);
            const MID_Y = Math.floor(ROWS / 2);


            // --- Biến Trạng thái Game ---
            let money = 500;
            let day = 1;
            let castleHealth = 100;
            let maxCastleHealth = 100;
            let castleLevel = 1; // Level Lâu đài
            let population = 0;
            let gameOver = false;
            let gameTime = 0; // Đếm thời gian trong ngày
            let isNight = false;
            let hasSpawnedTonight = false; // Cờ hiệu để đảm bảo quái chỉ spawn 1 lần/đêm

            let grid = []; // 2D array lưu trữ bản đồ
            let entities = []; // Lưu trữ nhà, tháp pháo
            let units = []; // Lưu trữ lính, kẻ thù
            let projectiles = []; // Lưu trữ đạn

            let selectedShopItem = null; // Item đang chọn từ shop
            let selectedEntity = null; // Công trình đang chọn để nâng cấp
            let selectedSoldier = null; // Lính đang chọn để di chuyển
            
            let mousePos = { x: 0, y: 0, gridX: 0, gridY: 0 };

            // Cài đặt thời gian (30s/ngày)
            const DAY_LENGTH_MS = 30000; 
            const NIGHT_START_RATIO = 0.75; 
            let dayTimerDisplay = DAY_LENGTH_MS / 1000;

            // Cài đặt kẻ thù
            let enemyStats = {
                spawnCount: 2,
                health: 10,
                damage: 2,
                speed: 0.6
            };
            // Vị trí spawn quái (chỉ dùng để xác định hướng)
            const spawnSides = [
                { gridX: COLS / 2, gridY: 0 }, // Trên
                { gridX: COLS / 2, gridY: ROWS - 1 }, // Dưới
                { gridX: 0, gridY: ROWS / 2 }, // Trái
                { gridX: COLS - 1, gridY: ROWS / 2 } // Phải
            ];
            
            // --- Lấy Element từ UI ---
            const moneyDisplay = document.getElementById('money-display');
            const dayDisplay = document.getElementById('day-display');
            const castleHealthDisplay = document.getElementById('castle-health-display');
            const populationDisplay = document.getElementById('population-display');
            const messageDisplay = document.getElementById('message-display');
            const shopItems = document.querySelectorAll('.shop-item');
            
            const upgradePanel = document.getElementById('upgrade-panel');
            const upgradeTitle = document.getElementById('upgrade-title');
            const upgradeLevel = document.getElementById('upgrade-level');
            const upgradeHealth = document.getElementById('upgrade-health');
            const upgradeInfo = document.getElementById('upgrade-info');
            const upgradeButton = document.getElementById('upgrade-button');
            const sellButton = document.getElementById('sell-button');

            // --- Lớp (Classes) ---

            class Entity {
                constructor(x, y, type, cost, health) {
                    this.x = x * GRID_SIZE;
                    this.y = y * GRID_SIZE;
                    this.gridX = x;
                    this.gridY = y;
                    this.size = GRID_SIZE;
                    this.type = type;
                    this.cost = cost;
                    this.health = health;
                    this.maxHealth = health;
                    this.level = 1;
                    this.id = Math.random();
                }

                draw() {
                    ctx.fillStyle = '#ccc'; // Màu mặc định
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    this.drawHealthBar();
                    
                    if(selectedEntity === this) {
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x - 1, this.y - 1, this.size + 2, this.size + 2);
                        ctx.lineWidth = 1;
                    }
                }
                
                drawHealthBar() {
                    if (this.health < this.maxHealth || this.type === 'castle') {
                        const barWidth = this.size;
                        const barHeight = 4;
                        const drawX = this.x + (this.type === 'castle' ? this.size/4 : 0);
                        const drawWidth = this.type === 'castle' ? this.size/2 : barWidth;
                        
                        ctx.fillStyle = '#333';
                        ctx.fillRect(drawX, this.y - barHeight - 2, drawWidth, barHeight);
                        ctx.fillStyle = this.type === 'castle' ? '#4a90e2' : 'green';
                        ctx.fillRect(drawX, this.y - barHeight - 2, drawWidth * (this.health / this.maxHealth), barHeight);
                    }
                }

                update() {
                    // Mặc định không làm gì
                }
                
                getUpgradeCost() {
                    // Lvl 1->2: 5$. Lvl 2->3: 10$. Lvl 3->4: 15$.
                    return 5 * this.level;
                }
                
                getSellValue() {
                    return Math.floor(this.cost / 2);
                }
                
                upgrade() {
                    if (this.level >= 10 && this.type !== 'castle') {
                        logMessage("Đã đạt cấp tối đa (Level 10)!");
                        return;
                    }
                    
                    const cost = this.getUpgradeCost();
                    if (money >= cost) {
                        money -= cost;
                        this.level++;
                        
                        if (this.type === 'castle') {
                            // Nâng cấp Castle: tăng máu, hồi full máu
                            this.maxHealth = Math.floor(this.maxHealth * 1.2); // +20%
                            this.health = this.maxHealth; // Hồi full
                            castleLevel = this.level;
                        } else {
                            this.maxHealth += Math.floor(this.maxHealth * 1.2); // +20% máu
                            this.health = this.maxHealth;
                        }

                        logMessage(`${this.type} đã lên Cấp ${this.level}!`);
                        
                        // Áp dụng nâng cấp riêng
                        this.applyUpgrade();
                        
                        // Cập nhật lại bảng nâng cấp
                        selectEntityForUpgrade(this);
                    } else {
                        logMessage("Không đủ tiền nâng cấp!");
                    }
                }
                
                applyUpgrade() {
                    // Các lớp con sẽ ghi đè (override)
                }

                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.destroy();
                    }
                }
                
                destroy() {
                    this.health = 0;
                    // Dọn dẹp grid
                    // Kiểm tra nếu nó là một công trình đã được đặt (giá trị 3)
                    if(grid[this.gridY] && grid[this.gridY][this.gridX] === 3) {
                         grid[this.gridY][this.gridX] = 0; // Trả lại Cỏ
                    }
                    // Nếu là Tường đặt trên Đường (giá trị 6), trả lại Đường
                    else if(grid[this.gridY] && grid[this.gridY][this.gridX] === 6) { 
                         grid[this.gridY][this.gridX] = 1; // Trả lại Đường
                    }
                    
                    if(this.type === 'shipyard') {
                        // Xưởng tàu trả lại Cỏ
                        grid[this.gridY][this.gridX] = 0;
                    }
                    
                    // Nếu là xưởng tàu, hủy tàu chiến
                    if(this.warship) this.warship.destroy();
                    
                    // Nếu là doanh trại, hủy lính
                    if(this.soldiers) this.soldiers.forEach(s => s.destroy());
                    
                    if(selectedEntity === this) {
                        hideUpgradePanel();
                    }
                }
            }

            class Castle extends Entity {
                constructor(x, y) {
                    super(x, y, 'castle', 0, maxCastleHealth);
                    this.size = GRID_SIZE * 2;
                    this.level = 1;
                }
                draw() {
                    ctx.fillStyle = COLORS.castle;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = '25px "Press Start 2P"';
                    ctx.fillText("♔", this.x + 8, this.y + 35);
                    
                    // Vẽ Level
                    ctx.font = '8px "Press Start 2P"';
                    ctx.fillText(`Lv${this.level}`, this.x + 5, this.y + 10);

                    this.drawHealthBar();
                }
                takeDamage(amount) {
                    this.health -= amount;
                    castleHealth = this.health;
                    if (this.health <= 0 && !gameOver) {
                        gameOver = true;
                        this.health = 0;
                        logMessage("GAME OVER! Lâu đài đã bị phá hủy.");
                    }
                }
                // Lâu đài có thể nâng cấp
                getUpgradeCost() { return 10 * this.level; } // Level 1: 10$, Lvl 2: 20$, ...
                getSellValue() { return 0; }
                
                select() {
                    selectEntityForUpgrade(this);
                }
            }
            
            // --- Các Lớp Công Trình ---

            class House extends Entity {
                constructor(x, y, type, cost, health, income) {
                    const baseIncome = (type === 'house') ? 3 : 5; 
                    super(x, y, type, cost, health);
                    this.income = baseIncome;
                }
                draw() {
                    if (this.type === 'house') {
                        // Nhà Nhỏ (Vẽ nhà mái đỏ tường vàng)
                        ctx.fillStyle = '#fef08a'; // Tường vàng nhạt
                        ctx.fillRect(this.x, this.y + 10, this.size, this.size - 10);
                        ctx.fillStyle = '#8b4513'; // Cửa gỗ
                        ctx.fillRect(this.x + 9, this.y + 15, 7, 10);
                        // Mái nhà
                        ctx.fillStyle = '#d62828'; // Mái đỏ
                        ctx.beginPath();
                        ctx.moveTo(this.x - 2, this.y + 12);
                        ctx.lineTo(this.x + this.size / 2, this.y - 2);
                        ctx.lineTo(this.x + this.size + 2, this.y + 12);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Farm (Nhà gia súc)
                        ctx.fillStyle = COLORS.farm; 
                        ctx.fillRect(this.x, this.y, this.size, this.size);
                        ctx.strokeStyle = '#000';
                        ctx.strokeRect(this.x, this.y, this.size, this.size);
                        // Hàng rào chuồng
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.x + 2, this.y + 15, this.size - 4, 8);
                        ctx.fillRect(this.x + 5, this.y + 10, 3, 13);
                        ctx.fillRect(this.x + 12, this.y + 10, 3, 13);
                        ctx.fillRect(this.x + 19, this.y + 10, 3, 13);
                        // Con vật (vẽ đơn giản)
                        ctx.fillStyle = '#fff'; // Cừu
                        ctx.fillRect(this.x + 5, this.y + 5, 5, 5);
                        ctx.fillStyle = '#ffc0cb'; // Heo
                        ctx.fillRect(this.x + 15, this.y + 8, 5, 4);
                    }
                    
                    this.drawHealthBar(); // Vẽ thanh máu (chuyển từ super.draw())
                }
                applyUpgrade() {
                    this.income += (this.type === 'house') ? 3 : 5; 
                }
            }
            
            class FarmPlot extends Entity { // Ruộng (Buff)
                constructor(x, y) {
                    super(x, y, 'farmplot', 13, 30);
                    this.buffBonus = 0.1; // 10%
                }
                draw() {
                    // Vẽ Ruộng Vàng
                    ctx.fillStyle = COLORS.farmplot; // Vàng ươm
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    // Vẽ các đường lằn
                    ctx.strokeStyle = '#b5835a'; // Nâu sẫm
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 5, this.y); ctx.lineTo(this.x + 5, this.y + this.size);
                    ctx.moveTo(this.x + 12, this.y); ctx.lineTo(this.x + 12, this.y + this.size);
                    ctx.moveTo(this.x + 19, this.y); ctx.lineTo(this.x + 19, this.y + this.size);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                    
                    this.drawHealthBar(); // Vẽ thanh máu
                }
                applyUpgrade() {
                    this.buffBonus += 0.2; 
                    logMessage(`Buff thuế của Ruộng tăng lên ${Math.round(this.buffBonus * 100)}%`);
                }
            }
            
            class Clinic extends Entity {
                constructor(x, y) {
                    super(x, y, 'clinic', 30, 60);
                }
                draw() {
                    // Vẽ Phòng khám cổ đại (có rêu)
                    ctx.fillStyle = COLORS.clinic; 
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    // Rêu mọc (vài pixel xanh)
                    ctx.fillStyle = '#556b2f'; 
                    ctx.fillRect(this.x, this.y + this.size - 3, 5, 3);
                    ctx.fillRect(this.x + 10, this.y + this.size - 2, 7, 2);
                    ctx.fillRect(this.x + 20, this.y + this.size - 4, 5, 4);
                    
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    // Mái nhà
                    ctx.fillStyle = '#a9a9a9';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.size / 2, this.y - this.size / 3);
                    ctx.lineTo(this.x + this.size, this.y);
                    ctx.closePath();
                    ctx.fill();
                    // Chữ thập đỏ
                    ctx.fillStyle = COLORS.enemy;
                    ctx.fillRect(this.x + 10, this.y + 5, 5, 15);
                    ctx.fillRect(this.x + 5, this.y + 10, 15, 5);
                    this.drawHealthBar();
                }
                applyUpgrade() {
                    // Logic tăng lính sẽ được xử lý toàn cục
                }
            }
            
            class Barracks extends Entity {
                constructor(x, y) {
                    super(x, y, 'barracks', 40, 80);
                    this.soldiers = [];
                    this.maxSoldiers = 5;
                    this.spawnCooldown = 0;
                    this.soldierBaseDamage = 2; 
                    this.currentWeaponLevel = 1; 
                    this.spawnSoldiers(); // Spawn lính ngay khi xây
                }
                
                spawnSoldiers(count = this.maxSoldiers) {
                     for(let i=0; i < count; i++) {
                        if(this.soldiers.length < this.maxSoldiers) {
                            const spawnPos = findEmptyNeighbor(this.gridX, this.gridY);
                            if(spawnPos) {
                                const weapon = getWeaponByLevel(this.currentWeaponLevel);
                                const newSoldier = new Soldier(
                                    spawnPos.x * GRID_SIZE, 
                                    spawnPos.y * GRID_SIZE, 
                                    this, 
                                    this.soldierBaseDamage, 
                                    weapon
                                );
                                units.push(newSoldier);
                                this.soldiers.push(newSoldier);
                                population++;
                            }
                        }
                    }
                }
                
                update() {
                    this.soldiers = this.soldiers.filter(s => s.health > 0);
                    if(this.spawnCooldown > 0) this.spawnCooldown--;
                }
                
                draw() {
                    // Vẽ Túp Lều
                    ctx.fillStyle = COLORS.barracks; // Màu vải lều (nâu)
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.size);
                    ctx.lineTo(this.x + this.size / 2, this.y + 5);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.closePath();
                    ctx.fill();
                    // Cửa lều
                    ctx.fillStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size / 2 - 4, this.y + this.size);
                    ctx.lineTo(this.x + this.size / 2, this.y + 15);
                    ctx.lineTo(this.x + this.size / 2 + 4, this.y + this.size);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Biểu tượng kiếm
                    const weapon = getWeaponByLevel(this.currentWeaponLevel);
                    ctx.fillStyle = weapon.color;
                    ctx.font = '15px "Press Start 2P"';
                    ctx.fillText("⚔", this.x + 4, this.y + 18);
                    
                    this.drawHealthBar();
                }
                
                applyUpgrade() {
                    this.maxSoldiers++;
                    if(this.level <= WEAPONS.length) {
                        this.currentWeaponLevel = this.level;
                    }
                    this.soldierBaseDamage *= 1.2;
                    this.soldiers.forEach(s => {
                        s.baseDamage = this.soldierBaseDamage;
                        s.weapon = getWeaponByLevel(this.currentWeaponLevel);
                        s.damage = s.weapon.damage * s.baseDamage;
                    });
                    this.spawnSoldiers(1); 
                }
                
                destroy() {
                    super.destroy();
                    this.soldiers.forEach(s => s.destroy());
                }
            }
            
            class Wall extends Entity {
                constructor(x, y) {
                    super(x, y, 'wall', 5, 250);
                }
                draw() {
                    // Vẽ "Mọt đinh" (Dragon's Teeth)
                    ctx.fillStyle = '#a9a9a9'; // Bê tông
                    // Vẽ 3 kim tự tháp nhỏ
                    // Cái 1 (trái)
                    ctx.beginPath();
                    ctx.moveTo(this.x + 2, this.y + this.size - 2);
                    ctx.lineTo(this.x + 8, this.y + 5);
                    ctx.lineTo(this.x + 14, this.y + this.size - 2);
                    ctx.closePath();
                    ctx.fill();
                    // Cái 2 (phải)
                    ctx.beginPath();
                    ctx.moveTo(this.x + 11, this.y + this.size - 2);
                    ctx.lineTo(this.x + 17, this.y + 5);
                    ctx.lineTo(this.x + 23, this.y + this.size - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Vẽ bóng đổ (làm cho nó 3D)
                    ctx.fillStyle = '#6c757d'; // Xám tối
                    ctx.beginPath();
                    ctx.moveTo(this.x + 8, this.y + 5);
                    ctx.lineTo(this.x + 14, this.y + this.size - 2);
                    ctx.lineTo(this.x + 8, this.y + this.size - 2); // Thêm 1 điểm
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x + 17, this.y + 5);
                    ctx.lineTo(this.x + 23, this.y + this.size - 2);
                    ctx.lineTo(this.x + 17, this.y + this.size - 2); // Thêm 1 điểm
                    ctx.closePath();
                    ctx.fill();
                    
                    this.drawHealthBar();
                }
                applyUpgrade() {
                    // Tường chỉ tăng máu
                }
            }
            
            class Tower extends Entity {
                constructor(x, y) {
                    super(x, y, 'tower', 50, 70);
                    this.range = 5 * GRID_SIZE;
                    this.damage = 1;
                    this.cooldown = 0;
                    this.maxCooldown = 60; // 1 giây
                    this.target = null;
                }
                draw() {
                    // Vẽ Tháp Canh (Kiểu Tháp Kiểm Lâm)
                    // Chân tháp (4 chân)
                    ctx.fillStyle = '#8b4513'; // Nâu gỗ
                    ctx.fillRect(this.x + 2, this.y + 10, 5, this.size - 10);
                    ctx.fillRect(this.x + this.size - 7, this.y + 10, 5, this.size - 10);
                    // Giằng chéo
                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(this.x + 4, this.y + 12); ctx.lineTo(this.x + this.size - 5, this.y + this.size - 2);
                    ctx.moveTo(this.x + 4, this.y + this.size - 2); ctx.lineTo(this.x + this.size - 5, this.y + 12);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                    
                    // Sàn tháp
                    ctx.fillStyle = COLORS.tower;
                    ctx.fillRect(this.x, this.y + 5, this.size, 8);
                    // Mái tháp
                    ctx.fillStyle = '#d62828';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + 5);
                    ctx.lineTo(this.x + this.size / 2, this.y - 5);
                    ctx.lineTo(this.x + this.size, this.y + 5);
                    ctx.closePath();
                    ctx.fill();
                    
                    this.drawHealthBar();
                    
                    // Vẽ tầm bắn khi được chọn
                    if (selectedEntity === this) {
                        ctx.beginPath();
                        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.range, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.stroke();
                    }
                }
                update() {
                    this.findAndShoot();
                }
                
                findAndShoot() {
                    if (this.cooldown > 0) {
                        this.cooldown--;
                        return;
                    }
                    
                    this.target = findNearestTarget(this, this.range, 'any_enemy'); 
                    
                    if (this.target) {
                        projectiles.push(new Projectile(
                            this.x + this.size / 2, 
                            this.y + this.size / 2, 
                            this.target, 
                            this.damage
                        ));
                        this.cooldown = this.maxCooldown; 
                    }
                }
                
                applyUpgrade() {
                    this.range += GRID_SIZE; 
                    this.damage *= 2; 
                    this.maxCooldown = Math.max(10, this.maxCooldown - 3); 
                }
            }
            
            class Shipyard extends Entity {
                constructor(x, y) {
                    super(x, y, 'shipyard', 100, 100);
                    this.warship = null;
                    this.spawnWarship();
                }
                
                spawnWarship() {
                    const waterNeighbor = findEmptyNeighbor(this.gridX, this.gridY, 4); 
                    if(waterNeighbor) {
                        const ship = new Warship(waterNeighbor.x, waterNeighbor.y, this);
                        this.warship = ship;
                        entities.push(ship);
                        grid[waterNeighbor.y][waterNeighbor.x] = 3; 
                    } else {
                        logMessage("Không tìm thấy mặt nước để đặt Tàu! (Cần ô nước kề bên)");
                    }
                }
                
                draw() {
                    ctx.fillStyle = COLORS.shipyard;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    ctx.fillStyle = '#f1faee';
                    ctx.font = '15px "Press Start 2P"';
                    ctx.fillText("⚓", this.x + 4, this.y + 18);
                    this.drawHealthBar();
                }
                
                applyUpgrade() {
                    if(this.warship) this.warship.upgrade(); 
                }
                
                destroy() {
                    super.destroy();
                    if(this.warship) this.warship.destroy();
                }
            }
            
            class Warship extends Tower { 
                constructor(x, y, shipyard) {
                    super(x, y); 
                    this.type = 'warship';
                    this.shipyard = shipyard; 
                    this.health = 150;
                    this.maxHealth = 150;
                    this.range = 30 * GRID_SIZE; 
                    this.damage = 5;
                    this.maxCooldown = 120; // 2 giây
                    this.cooldown = 0;
                    // --- SỬA LỖI TÀU CHIẾN ---
                    this.splashRadius = 0; // Sát thương lan (0 = không có)
                    // --- KẾT THÚC SỬA LỖI ---
                }
                
                draw() {
                    if (this.level === 1) {
                        // Level 1: Thuyền buồm nhỏ
                        ctx.fillStyle = '#6e442c';
                        ctx.fillRect(this.x, this.y + 5, this.size, this.size - 10);
                        ctx.fillStyle = COLORS.projectile;
                        ctx.fillRect(this.x + 10, this.y - 5, 5, this.size);
                    } else if (this.level === 2) {
                        // Level 2: Thuyền chiến
                        ctx.fillStyle = '#593b2b'; 
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + 5);
                        ctx.lineTo(this.x + this.size, this.y + 5);
                        ctx.lineTo(this.x + this.size - 4, this.y + this.size - 2);
                        ctx.lineTo(this.x + 4, this.y + this.size - 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = COLORS.projectile;
                        ctx.fillRect(this.x + 10, this.y - 5, 5, this.size);
                        ctx.fillStyle = '#333';
                        ctx.fillRect(this.x + 5, this.y + 10, 5, 5);
                        ctx.fillRect(this.x + 15, this.y + 10, 5, 5);
                    } else {
                        // Level 3+: Tàu khu trục
                        ctx.fillStyle = '#6c757d'; 
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + 8);
                        ctx.lineTo(this.x + this.size, this.y + 8);
                        ctx.lineTo(this.x + this.size - 3, this.y + this.size - 5);
                        ctx.lineTo(this.x + 3, this.y + this.size - 5);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#333';
                        ctx.fillRect(this.x + 5, this.y + 5, 15, 5);
                        ctx.fillRect(this.x + 10, this.y, 5, 10);
                        ctx.fillStyle = '#a9a9a9';
                        ctx.fillRect(this.x + 8, this.y + 10, 9, 9);
                    }
                    
                    this.drawHealthBar(); // Vẽ thanh máu
                    
                    // Vẽ tầm bắn VÀ BÁN KÍNH LAN
                    if (selectedEntity === this.shipyard) {
                        // Tầm bắn
                        ctx.beginPath();
                        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.range, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.stroke();
                        
                        // Bán kính lan (nếu có)
                        if (this.splashRadius > 0) {
                            ctx.beginPath();
                            ctx.arc(this.x + this.size / 2, this.y + this.size / 2, this.splashRadius * GRID_SIZE, 0, Math.PI * 2);
                            ctx.fillStyle = 'rgba(214, 40, 40, 0.2)';
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(214, 40, 40, 0.5)';
                            ctx.stroke();
                        }
                    }
                }
                
                // Nâng cấp Tàu chiến (được gọi bởi Xưởng Tàu)
                upgrade() {
                    this.level++; 
                    this.range += GRID_SIZE; 
                    this.damage *= 1.5; 
                    // --- SỬA LỖI TÀU CHIẾN ---
                    this.splashRadius += 0.2; // Tăng bán kính lan (0.2 ô = 5px)
                    // --- KẾT THÚC SỬA LỖI ---
                    this.maxHealth += 30;
                    this.health = this.maxHealth;
                    this.maxCooldown = Math.max(30, this.maxCooldown - 15);
                }
                
                // --- SỬA LỖI TÀU CHIẾN ---
                // Ghi đè hàm findAndShoot để bắn đạn lan
                findAndShoot() {
                    if (this.cooldown > 0) {
                        this.cooldown--;
                        return;
                    }
                    
                    this.target = findNearestTarget(this, this.range, 'any_enemy'); 
                    
                    if (this.target) {
                        projectiles.push(new Projectile(
                            this.x + this.size / 2, 
                            this.y + this.size / 2, 
                            this.target, 
                            this.damage,
                            COLORS.projectile,
                            this.splashRadius * GRID_SIZE // Truyền bán kính lan (px)
                        ));
                        this.cooldown = this.maxCooldown; 
                    }
                }
                // --- KẾT THÚC SỬA LỖI ---
                
                destroy() {
                    super.destroy(); 
                    if(this.shipyard) this.shipyard.warship = null; 
                    if(grid[this.gridY] && grid[this.gridY][this.gridX] === 3) {
                         grid[this.gridY][this.gridX] = 4;
                    }
                }
            }

            // --- Các Lớp Đơn vị (Units) ---
            
            class Unit {
                constructor(x, y, health, baseDamage, speed, type) {
                    this.x = x;
                    this.y = y;
                    this.health = health;
                    this.maxHealth = health;
                    this.baseDamage = baseDamage;
                    this.damage = baseDamage; 
                    this.speed = speed;
                    this.type = type; // 'enemy', 'orc', 'catapult', 'soldier'
                    this.id = Math.random();
                    this.target = null;
                    this.size = 15;
                    this.attackCooldown = 0;
                    this.weapon = null; 
                }
                
                draw() {
                    // Chọn màu
                    let color = COLORS.enemy;
                    if (this.type === 'soldier') color = COLORS.soldier;
                    else if (this.type === 'orc') color = COLORS.orc;
                    else if (this.type === 'catapult') color = COLORS.catapult;
                    
                    ctx.fillStyle = color;
                    
                    if (this.type !== 'catapult') {
                        ctx.beginPath();
                        ctx.arc(this.x + GRID_SIZE / 2, this.y + GRID_SIZE / 2, this.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Vẽ Máy bắn đá
                        ctx.fillRect(this.x, this.y + 5, this.size, this.size / 2); // Thân xe
                        ctx.fillStyle = '#8b4513';
                        ctx.fillRect(this.x + 5, this.y, 5, this.size); // Cần cẩu
                    }
                    
                    if (this.weapon) {
                        ctx.fillStyle = this.weapon.color;
                        ctx.font = '10px "Press Start 2P"';
                        ctx.fillText("†", this.x + 12, this.y + 12); 
                    }
                    
                    // Vẽ thanh máu
                    const barWidth = this.size + 5;
                    const barHeight = 4;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y - 8, barWidth, barHeight);
                    ctx.fillStyle = (this.type === 'soldier') ? 'green' : 'red';
                    ctx.fillRect(this.x, this.y - 8, barWidth * (this.health / this.maxHealth), barHeight);
                    
                    if (selectedSoldier === this) {
                        ctx.strokeStyle = '#f1c40f';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.x + GRID_SIZE / 2, this.y + GRID_SIZE / 2, this.size / 2 + 3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.lineWidth = 1;
                    }
                }
                
                // --- SỬA LỖI TƯỜNG (A) ---
                // Hàm update() này sẽ được dùng chung cho Enemy, Orc
                update() {
                    if(this.attackCooldown > 0) this.attackCooldown--;
                    
                    // 1. Tìm mục tiêu (Lính sẽ xử lý riêng, Máy bắn đá xử lý riêng)
                    if (!this.target || this.target.health <= 0) {
                        if (this.type !== 'soldier' && this.type !== 'catapult') {
                            this.findTarget();
                        }
                    }
                    
                    if (this.target && this.target.health <= 0) {
                        this.target = null;
                        // return; // Không return, để nó đi về Lâu đài
                    }
                    
                    // 2. Nếu không có mục tiêu, đi về Lâu đài
                    if (!this.target) {
                        if(this.type !== 'soldier' && this.type !== 'catapult') {
                            this.moveToCastle();
                        }
                        return; // Lính và Catapult có logic riêng
                    }

                    // 3. Kiểm tra va chạm Tường
                    const angle = Math.atan2(
                        (this.target.y + (this.target.size || GRID_SIZE) / 2) - (this.y + GRID_SIZE / 2), 
                        (this.target.x + (this.target.size || GRID_SIZE) / 2) - (this.x + GRID_SIZE / 2)
                    );
                    
                    // Tính toán vị trí tiếp theo
                    const nextX = this.x + Math.cos(angle) * this.speed;
                    const nextY = this.y + Math.sin(angle) * this.speed;
                    // Lấy ô grid của vị trí TIẾP THEO
                    const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                    const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                    
                    const blockingEntity = getEntityAt(nextGridX, nextGridY);
                    let effectiveTarget = this.target; // Mục tiêu thực tế

                    if (blockingEntity && blockingEntity.type === 'wall' && blockingEntity !== this.target) {
                        // Nếu bước tiếp theo là Tường, VÀ nó không phải mục tiêu cuối cùng
                        // -> Tường trở thành mục tiêu
                        effectiveTarget = blockingEntity;
                    }
                    // --- KẾT THÚC SỬA LỖI TƯỜNG (A) ---
                    
                    // 4. Hành động (Tấn công hoặc Di chuyển)
                    const targetSize = (effectiveTarget.type === 'castle') ? effectiveTarget.size * 0.7 : (effectiveTarget.size || GRID_SIZE) / 2 + 5;
                    const dist = getDistance(this, effectiveTarget);
                    
                    if (dist < targetSize) {
                        // Tấn công (effectiveTarget có thể là Lính, Lâu đài, hoặc Tường)
                        this.attack(effectiveTarget); // Truyền mục tiêu vào hàm attack
                    } else {
                        // Di chuyển (chỉ khi không bị tường cản)
                        if (effectiveTarget.type !== 'wall') {
                            this.x = nextX;
                            this.y = nextY;
                        }
                        // Nếu effectiveTarget là tường, nó sẽ đứng im (vì dist > targetSize)
                        // và đợi vòng lặp sau tấn công (khi dist < targetSize)
                    }
                }
                
                findTarget() {
                    // Lớp con sẽ ghi đè
                }
                
                // --- SỬA LỖI TƯỜNG (B) ---
                // Cập nhật hàm attack để nhận tham số
                attack(target) {
                    if (this.attackCooldown === 0 && target) {
                        target.takeDamage(this.damage);
                        this.attackCooldown = 90; // 1.5 giây
                        // Quái vật biến mất nếu tấn công lâu đài
                        if(this.type.includes('enemy') && target.type === 'castle') {
                             this.destroy();
                        }
                    }
                }
                // --- KẾT THÚC SỬA LỖI TƯỜNG (B) ---
                
                moveToTarget() {
                    // Logic này đã được chuyển vào update()
                }
                
                moveToCastle() {
                    const castle = entities.find(e => e.type === 'castle');
                    if(!castle) return;
                    
                    // --- SỬA LỖI TƯỜNG (C) ---
                    // Logic di chuyển về Lâu đài CŨNG PHẢI kiểm tra Tường
                    const angle = Math.atan2(castle.y + castle.size/2 - this.y, castle.x + castle.size/2 - this.x);
                    
                    const nextX = this.x + Math.cos(angle) * this.speed;
                    const nextY = this.y + Math.sin(angle) * this.speed;
                    const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                    const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                    
                    const blockingEntity = getEntityAt(nextGridX, nextGridY);
                    
                    if (blockingEntity && blockingEntity.type === 'wall') {
                        // Nếu Tường cản đường về Lâu đài -> Tấn công Tường
                        this.target = blockingEntity;
                    } 
                    else if (getDistance(this, castle) < castle.size / 2) {
                        // Nếu đến Lâu đài -> Tấn công Lâu đài
                        this.target = castle;
                    }
                    else {
                        // Di chuyển
                        this.x = nextX;
                        this.y = nextY;
                    }
                    // --- KẾT THÚC SỬA LỖI TƯỜNG (C) ---
                }
                
                takeDamage(amount) {
                    this.health -= amount;
                    if(this.health <= 0) this.destroy();
                }
                
                destroy() {
                    this.health = 0;
                    if(this.type === 'soldier') {
                        population--;
                        if (selectedSoldier === this) selectedSoldier = null;
                    }
                }
            }
            
            class Enemy extends Unit {
                constructor(x, y, health, baseDamage, speed, weapon) {
                    super(x, y, health, baseDamage, speed, 'enemy');
                    this.castle = entities.find(e => e.type === 'castle');
                    this.weapon = weapon || getRandomWeapon();
                    this.damage = this.baseDamage * this.weapon.damage; 
                }
                
                findTarget() {
                    // Ưu tiên 1: Lính (Soldier)
                    this.target = findNearestTarget(this, 10 * GRID_SIZE, 'soldier');
                    if(this.target) return;
                    
                    // Ưu tiên 2: Hàng rào/Doanh trại
                    // (Tường sẽ được xử lý bằng logic va chạm, không cần tìm ở đây)
                    const barracks = entities.filter(e => e.type === 'barracks' && e.health > 0);
                    this.target = findNearestEntity(this, barracks, 10 * GRID_SIZE);
                    if(this.target) return;
                    
                    // Ưu tiên 3: Tháp pháo
                    const towers = entities.filter(e => (e.type === 'tower' || e.type === 'warship') && e.health > 0);
                    this.target = findNearestEntity(this, towers, 10 * GRID_SIZE);
                    if(this.target) return;

                    // Ưu tiên 4: Lâu đài
                    this.target = this.castle;
                }
                
                // Kế thừa update() và attack() từ Unit (đã sửa lỗi Tường)
            }
            
            class OrcEnemy extends Enemy {
                constructor(x, y) {
                    const baseHealth = (enemyStats.health * 8) + (Math.random() * day * 4);
                    const baseDamage = enemyStats.damage * 5;
                    const baseSpeed = enemyStats.speed * 0.8;
                    
                    super(x, y, baseHealth, baseDamage, baseSpeed, getWeaponByLevel(3)); 
                    this.type = 'orc';
                    this.size = 20; 
                }
                // Kế thừa findTarget(), update(), attack() (đã sửa lỗi Tường)
            }
            
            class EnemyCatapult extends Unit {
                constructor(x, y) {
                    const baseHealth = (enemyStats.health * 7) + (Math.random() * day);
                    const baseDamage = enemyStats.damage * 10;
                    const baseSpeed = enemyStats.speed * 0.3;
                    
                    super(x, y, baseHealth, baseDamage, baseSpeed, 'catapult');
                    this.castle = entities.find(e => e.type === 'castle');
                    this.range = 7 * GRID_SIZE; // Tầm bắn xa
                    this.attackCooldown = 0;
                    this.maxCooldown = 240; // 3 giây
                }
                
                // --- SỬA LỖI TƯỜNG (D) ---
                // Máy bắn đá có logic update() riêng
                update() {
                    if (this.attackCooldown > 0) this.attackCooldown--;
                    
                    // 1. Tìm mục tiêu (ưu tiên Lâu đài/Công trình)
                    if (!this.target || this.target.health <= 0) {
                        this.findTarget();
                    }
                    if (this.target && this.target.health <= 0) {
                        this.target = null;
                        this.findTarget(); // Tìm mục tiêu mới ngay
                    }
                    if (!this.target) {
                        this.moveToCastle(); // Không có mục tiêu? Về lâu đài
                        return;
                    }

                    // 2. Kiểm tra Tầm bắn
                    const dist = getDistance(this, this.target);
                    if (dist < this.range) {
                        // 3. TRONG TẦM BẮN
                        // (Không cần kiểm tra tường, vì đạn sẽ va chạm)
                        this.attack(this.target); // Bắn
                    } else {
                        // 4. NGOÀI TẦM BẮN -> Di chuyển
                        // Logic di chuyển CẦN kiểm tra Tường
                        
                        const angle = Math.atan2(
                            (this.target.y + this.target.size / 2) - (this.y + this.size / 2), 
                            (this.target.x + this.target.size / 2) - (this.x + this.size / 2)
                        );
                        
                        const nextX = this.x + Math.cos(angle) * this.speed;
                        const nextY = this.y + Math.sin(angle) * this.speed;
                        const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                        const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                        
                        const blockingEntity = getEntityAt(nextGridX, nextGridY);

                        if (blockingEntity && blockingEntity.type === 'wall') {
                            // Bị Tường cản -> Tấn công Tường
                            this.attack(blockingEntity);
                        } else {
                            // Di chuyển
                            this.x = nextX;
                            this.y = nextY;
                        }
                    }
                }
                // --- KẾT THÚC SỬA LỖI TƯỜNG (D) ---
                
                findTarget() {
                    // Ưu tiên 1: Lâu đài
                    this.target = this.castle;
                    if(getDistance(this, this.castle) < this.range) return;

                    // Ưu tiên 2: Tháp pháo/Xưởng tàu (Công trình phòng thủ)
                    const defenses = entities.filter(e => (e.type === 'tower' || e.type === 'shipyard' || e.type === 'warship') && e.health > 0);
                    this.target = findNearestEntity(this, defenses, this.range * 1.5); // Tăng tầm tìm kiếm
                    if(this.target) return;
                    
                    // Ưu tiên 3: Doanh trại/Tường (BÂY GIỜ NÓ SẼ TẤN CÔNG TƯỜNG NẾU CẢN ĐƯỜNG)
                    const buildings = entities.filter(e => e.type === 'barracks' && e.health > 0);
                    this.target = findNearestEntity(this, buildings, this.range * 1.5);
                    if(this.target) return;
                    
                    this.target = this.castle;
                }
                
                // Ghi đè hàm attack để bắn đạn
                attack(target) {
                    if (this.attackCooldown === 0 && target) {
                        // Bắn đạn
                        projectiles.push(new Projectile(
                            this.x + this.size / 2, 
                            this.y + this.size / 2, 
                            target, // Bắn mục tiêu (có thể là Tường)
                            this.damage,
                            '#8b4513' // Đạn đá
                        ));
                        
                        this.attackCooldown = this.maxCooldown;
                        
                        // Xử lý sát thương đặc biệt với Lâu đài
                        if(target.type === 'castle') {
                            target.takeDamage(this.damage * 0.3); 
                        }
                    }
                }
            }
            
            class Soldier extends Unit {
                constructor(x, y, barracks, baseDamage, weapon) {
                    super(x, y, 20, baseDamage, 0.8, 'soldier');
                    this.barracks = barracks; 
                    this.weapon = weapon;
                    this.damage = this.baseDamage * this.weapon.damage; 
                    this.manualTargetPos = null; 
                }
                
                findTarget() {
                    this.target = findNearestTarget(this, 15 * GRID_SIZE, 'any_enemy'); 
                }
                
                // --- SỬA LỖI TƯỜNG (E) ---
                // Lính có logic update() riêng
                update() {
                    if(this.attackCooldown > 0) this.attackCooldown--;
                    
                    // 1. Kiểm tra mục tiêu thủ công (di chuyển)
                    if (this.manualTargetPos) {
                        const dist = getDistance(this, this.manualTargetPos, true); 
                        
                        if (dist > this.speed * 2) { // Cần 1 khoảng đệm
                            const angle = Math.atan2(this.manualTargetPos.y - (this.y + GRID_SIZE/2), this.manualTargetPos.x - (this.x + GRID_SIZE/2));
                            
                            // Kiểm tra tường
                            const nextX = this.x + Math.cos(angle) * this.speed;
                            const nextY = this.y + Math.sin(angle) * this.speed;
                            const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                            const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                            const blockingEntity = getEntityAt(nextGridX, nextGridY);

                            if (blockingEntity && blockingEntity.type === 'wall') {
                                // Đụng tường, hủy lệnh
                                this.manualTargetPos = null;
                            } else {
                                this.x = nextX;
                                this.y = nextY;
                            }
                        } else {
                            // Đến nơi
                            this.manualTargetPos = null;
                        }
                        // Khi đang di chuyển, vẫn tìm quái
                        this.findTarget();
                    }

                    // 2. Kiểm tra mục tiêu (Quái vật)
                    if (!this.target || this.target.health <= 0) {
                        this.findTarget();
                    }
                    if (this.target && this.target.health <= 0) {
                        this.target = null;
                    }

                    // 3. Hành động (Ưu tiên Tấn công quái)
                    if (this.target) {
                        // Nếu có quái, hủy lệnh di chuyển thủ công
                        this.manualTargetPos = null; 
                        
                        const targetSize = (this.target.size || GRID_SIZE) / 2 + 5;
                        const dist = getDistance(this, this.target);
                        
                        if (dist < targetSize) {
                            // Tấn công
                            this.attack(this.target);
                        } else {
                            // Di chuyển (KIỂM TRA TƯỜNG)
                            const angle = Math.atan2(
                                (this.target.y + this.target.size / 2) - (this.y + this.size / 2), 
                                (this.target.x + this.target.size / 2) - (this.x + this.size / 2)
                            );
                            
                            const nextX = this.x + Math.cos(angle) * this.speed;
                            const nextY = this.y + Math.sin(angle) * this.speed;
                            const nextGridX = Math.floor((nextX + GRID_SIZE / 2) / GRID_SIZE);
                            const nextGridY = Math.floor((nextY + GRID_SIZE / 2) / GRID_SIZE);
                            const blockingEntity = getEntityAt(nextGridX, nextGridY);

                            if (!blockingEntity || blockingEntity.type !== 'wall') {
                                // Không có tường, di chuyển
                                this.x = nextX;
                                this.y = nextY;
                            }
                            // Nếu có tường, lính sẽ đứng im
                        }
                    } else if (!this.manualTargetPos && this.barracks) {
                        // 4. Nếu không có lệnh, không có quái -> Quay về Doanh trại
                        // (Logic này chưa kiểm tra tường, lính có thể bị kẹt nếu xây bít)
                        const dist = getDistance(this, this.barracks);
                        if(dist > 5 * GRID_SIZE) { 
                             const angle = Math.atan2(this.barracks.y - this.y, this.barracks.x - this.x);
                             this.x += Math.cos(angle) * (this.speed * 0.5);
                             this.y += Math.sin(angle) * (this.speed * 0.5);
                        }
                    }
                }
                // --- KẾT THÚC SỬA LỖI TƯỜNG (E) ---
            }
            
            class Projectile {
                // --- SỬA LỖI TÀU CHIẾN (Splash) ---
                constructor(x, y, target, damage, color = COLORS.projectile, splashRadius = 0) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.damage = damage;
                    this.speed = 4;
                    this.size = 5;
                    this.id = Math.random();
                    this.color = color;
                    this.splashRadius = splashRadius; // Bán kính lan (px)
                }
                // --- KẾT THÚC SỬA LỖI TÀU CHIẾN ---
                
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // --- SỬA LỖI TƯỜNG (F) ---
                update() {
                    if (!this.target || this.target.health <= 0) {
                        this.destroy();
                        return;
                    }
                    
                    const targetCenterX = this.target.x + (this.target.size || GRID_SIZE) / 2;
                    const targetCenterY = this.target.y + (this.target.size || GRID_SIZE) / 2;
                    
                    const angle = Math.atan2(targetCenterY - this.y, targetCenterX - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                    
                    // 1. Kiểm tra va chạm Tường (Ưu tiên cao nhất)
                    const currentGridX = Math.floor(this.x / GRID_SIZE);
                    const currentGridY = Math.floor(this.y / GRID_SIZE);
                    const entityAtPos = getEntityAt(currentGridX, currentGridY);
                    
                    if (entityAtPos && entityAtPos.type === 'wall') {
                        // Đạn va chạm Tường!
                        this.applySplashDamage(entityAtPos.x, entityAtPos.y, entityAtPos); // Gây sát thương (kể cả lan)
                        this.destroy();
                        return;
                    }

                    // 2. Kiểm tra va chạm Mục tiêu
                    if (getDistance(this, this.target) < (this.target.size || GRID_SIZE) / 2) {
                        this.applySplashDamage(this.target.x, this.target.y, this.target); // Gây sát thương (kể cả lan)
                        this.destroy();
                    }
                }
                
                // Hàm mới để xử lý sát thương (đơn hoặc lan)
                applySplashDamage(hitX, hitY, directHitTarget) {
                    // Gây sát thương cho mục tiêu bị bắn trúng trực tiếp
                    directHitTarget.takeDamage(this.damage);
                    
                    // Nếu có sát thương lan (từ Tàu Chiến)
                    if (this.splashRadius > 0) {
                        const splashCenter = { 
                            x: hitX + GRID_SIZE / 2, 
                            y: hitY + GRID_SIZE / 2
                        };
                        
                        // Tìm tất cả quái vật trong bán kính lan
                        units.forEach(unit => {
                            if (unit.type.includes('enemy') || unit.type === 'orc' || unit.type === 'catapult') {
                                // Không gây sát thương 2 lần cho mục tiêu chính
                                if (unit.id === directHitTarget.id) return; 
                                
                                const dist = getDistance(unit, splashCenter, true);
                                if (dist < this.splashRadius) {
                                    unit.takeDamage(this.damage * 0.5); // Gây 50% sát thương lan
                                }
                            }
                        });
                    }
                }
                // --- KẾT THÚC SỬA LỖI TƯỜNG (F) ---

                destroy() {
                    this.damage = 0; // Đánh dấu để xóa
                }
            }

            // --- Hàm Khởi tạo Game ---
            function init() {
                // Tạo 2D grid
                grid = new Array(ROWS).fill(null).map(() => new Array(COLS).fill(0)); // 0 = Cỏ
                
                const MID_X = Math.floor(COLS / 2); // 12
                const MID_Y = Math.floor(ROWS / 2); // 12
                
                // Vẽ Hồ nước (Hồ rộng)
                const lakeStart = {x: 2, y: 15};
                const lakeEnd = {x: 10, y: 22};
                for(let y = lakeStart.y; y < lakeEnd.y; y++) {
                    for(let x = lakeStart.x; x < lakeEnd.x; x++) {
                        grid[y][x] = 4; // 4 = Nước
                    }
                }
                
                // Vẽ Đá (4 góc)
                for(let y=0; y < 5; y++) {
                    for(let x=0; x < 5; x++) {
                        if(x+y < 5) {
                            grid[y][x] = 5; // 5 = Đá
                            grid[ROWS-1-y][x] = 5;
                            grid[y][COLS-1-x] = 5;
                            grid[ROWS-1-y][COLS-1-x] = 5;
                        }
                    }
                }

                // Vẽ 4 con đường (rộng 2 ô)
                for(let x = 0; x < COLS; x++) { // Ngang
                    grid[MID_Y-1][x] = (grid[MID_Y-1][x] === 0 || grid[MID_Y-1][x] === 1) ? 1 : grid[MID_Y-1][x];
                    grid[MID_Y][x] = (grid[MID_Y][x] === 0 || grid[MID_Y][x] === 1) ? 1 : grid[MID_Y][x];
                }
                for(let y = 0; y < ROWS; y++) { // Dọc
                    grid[y][MID_X-1] = (grid[y][MID_X-1] === 0 || grid[y][MID_X-1] === 1) ? 1 : grid[y][MID_X-1];
                    grid[y][MID_X] = (grid[y][MID_X] === 0 || grid[y][MID_X] === 1) ? 1 : grid[y][MID_X];
                }

                // Đặt Lâu đài (2x2)
                const castle = new Castle(MID_X-1, MID_Y-1);
                entities.push(castle);
                grid[MID_Y-1][MID_X-1] = 2; // 2 = Lâu đài
                grid[MID_Y-1][MID_X] = 2;
                grid[MID_Y][MID_X-1] = 2;
                grid[MID_Y][MID_X] = 2;
                
                // Cập nhật biến toàn cục
                maxCastleHealth = castle.maxHealth;
                castleHealth = castle.health;
                castleLevel = castle.level;

                setupEventListeners();
                updateShopUI();
                gameLoop(0);
            }

            // --- Vòng lặp Game ---
            let lastTime = 0;
            function gameLoop(currentTime) {
                if (gameOver) {
                    drawGameOver();
                    return;
                }
                
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                if(!deltaTime) { // Bỏ qua frame đầu
                    requestAnimationFrame(gameLoop);
                    return;
                }

                gameTime += deltaTime;
                dayTimerDisplay = (DAY_LENGTH_MS - gameTime) / 1000;
                isNight = (gameTime / DAY_LENGTH_MS) > NIGHT_START_RATIO;
                
                // Bắt đầu ngày mới
                if (gameTime >= DAY_LENGTH_MS) {
                    gameTime = 0;
                    startNewDay();
                }
                
                update(deltaTime);
                draw();
                updateUI();

                requestAnimationFrame(gameLoop);
            }

            // --- Logic Cập nhật (Update) ---
            function update(deltaTime) {
                entities.forEach(e => e.update());
                units.forEach(u => u.update());
                projectiles.forEach(p => p.update());

                // LOGIC QUÁI VẬT TẤN CÔNG: 
                if (isNight && !hasSpawnedTonight && day > 1) {
                    spawnEnemiesOnce();
                }

                // Xóa các đối tượng "chết"
                entities = entities.filter(e => e.health > 0);
                units = units.filter(u => u.health > 0);
                projectiles = projectiles.filter(p => p.damage > 0);
            }

            // --- Logic Vẽ (Draw) ---
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Vẽ Nền (Cỏ, Đường, Nước, Đá)
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        let color = COLORS.grass;
                        if (grid[y][x] === 1) color = COLORS.path;
                        else if (grid[y][x] === 4) color = COLORS.water;
                        else if (grid[y][x] === 5) color = COLORS.rock;
                        else if (grid[y][x] === 6) color = COLORS.path; // Wall on Path
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        
                        // --- SỬA LỖI TƯỜNG (G) ---
                        // Vẽ Cỏ (0) lên trên Đường (1, 6) và Nước (4) để tạo hiệu ứng cỏ mọc
                        // Giữ nguyên Đá (5) và Lâu đài (2)
                        if (grid[y][x] !== 0 && grid[y][x] !== 2 && grid[y][x] !== 3 && grid[y][x] !== 5) {
                            ctx.fillStyle = 'rgba(42, 157, 143, 0.2)'; // Cỏ mờ
                            ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                        }
                        // --- KẾT THÚC SỬA LỖI TƯỜNG (G) ---
                    }
                }
                
                entities.forEach(e => e.draw());
                units.forEach(u => u.draw());
                projectiles.forEach(p => p.draw());

                // Vẽ Lớp phủ Đêm/Ngày
                drawDayNightCycle();

                // Vẽ ô vuông preview khi đặt nhà
                if (selectedShopItem) {
                    drawPlacementPreview();
                }
                
                if (selectedSoldier && selectedSoldier.manualTargetPos) {
                    ctx.fillStyle = '#f1c40f';
                    ctx.font = '15px "Press Start 2P"';
                    ctx.fillText("⚑", selectedSoldier.manualTargetPos.x - 8, selectedSoldier.manualTargetPos.y + 5);
                }
            }
            
            function drawDayNightCycle() {
                let opacity = 0;
                const nightTime = DAY_LENGTH_MS * (1 - NIGHT_START_RATIO); // 7.5s
                const dayTime = DAY_LENGTH_MS * NIGHT_START_RATIO; // 22.5s
                
                if (isNight) {
                    opacity = Math.min(0.6, (gameTime - dayTime) / (nightTime / 2) * 0.6);
                } else {
                    if(gameTime > dayTime - nightTime / 2) {
                        opacity = (gameTime - (dayTime - nightTime / 2)) / (nightTime / 2) * 0.6;
                    }
                }

                if (opacity > 0) {
                    ctx.fillStyle = `rgba(0, 0, 50, ${opacity})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
            
            function drawPlacementPreview() {
                const x = mousePos.gridX;
                const y = mousePos.gridY;
                const size = GRID_SIZE;

                let canPlace = canBuildAt(selectedShopItem.type, x, y);
                
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = canPlace ? 'green' : 'red';
                ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, size, size);
                ctx.globalAlpha = 1.0;
            }

            function drawGameOver() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'red';
                ctx.font = '30px var(--font-family)';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
                ctx.fillStyle = 'white';
                ctx.font = '14px var(--font-family)';
                ctx.fillText('Bạn trụ được ' + (day - 1) + ' ngày', canvas.width / 2, canvas.height / 2 + 20);
                ctx.font = '10px var(--font-family)';
                ctx.fillText('Nhấn F5 để chơi lại', canvas.width / 2, canvas.height / 2 + 50);
            }

            // --- Cập nhật UI ---
            function updateUI() {
                moneyDisplay.textContent = `Tiền: ${Math.floor(money)}$`;
                dayDisplay.textContent = `Ngày: ${day} (${isNight ? 'Đêm' : 'Ngày'} ${Math.ceil(dayTimerDisplay)}s) | Lv: ${castleLevel}`; 
                castleHealthDisplay.textContent = `Lâu Đài: ${Math.floor(castleHealth)}/${maxCastleHealth} HP`;
                populationDisplay.textContent = `Lính: ${population}`;
                
                updateShopUI(); 
            }
            
            function updateShopUI() {
                shopItems.forEach(item => {
                    const cost = parseInt(item.dataset.cost);
                    if (money < cost) {
                        item.classList.add('disabled');
                    } else {
                        item.classList.remove('disabled');
                    }
                    
                    if(item.dataset.type === 'clinic') {
                        const clinicCount = entities.filter(e => e.type === 'clinic').length;
                        if(clinicCount >= 3) { // Giới hạn 3
                            item.classList.add('disabled');
                            item.querySelector('.cost').textContent = "Tối đa: 3";
                        } else {
                            item.querySelector('.cost').textContent = `Giá: ${cost}$`;
                        }
                    }
                });
            }
            
            function showUpgradePanel(entity) {
                selectedEntity = entity;
                selectedSoldier = null; 
                upgradePanel.style.display = 'block';
                upgradeTitle.textContent = `${entity.type === 'castle' ? 'Lâu Đài' : entity.type} (Cấp ${entity.level})`;
                upgradeHealth.textContent = `Máu: ${Math.floor(entity.health)}/${entity.maxHealth}`;
                
                let info = "";
                if(entity.income) info = `Thu nhập: ${entity.income}$/ngày`;
                if(entity.type === 'farmplot') info = `Buff Thuế: +${Math.round(entity.buffBonus * 100)}%`;
                if(entity.type === 'clinic') info = `Hồi: ${entity.level} lính/đêm (toàn cục)`;
                if(entity.type === 'tower') info = `Tầm: ${entity.range/GRID_SIZE} - Thiệt hại: ${entity.damage} - Tốc độ: ${(entity.maxCooldown / 60).toFixed(2)}s`;
                if(entity.type === 'barracks') {
                    const nextWeaponLevel = Math.min(entity.level + 1, WEAPONS.length);
                    info = `Tối đa: ${entity.maxSoldiers} Lính. Vũ khí: ${getWeaponByLevel(entity.currentWeaponLevel).name}. ${entity.level < 4 ? `(Lên cấp ${nextWeaponLevel} đổi sang ${getWeaponByLevel(nextWeaponLevel).name})` : ''}`;
                }
                if(entity.type === 'shipyard') info = `Nâng cấp Tàu Chiến (Lv ${entity.warship ? entity.warship.level : 1})`;
                if(entity.type === 'warship') info = `Tàu Chiến Lv ${entity.level} - Dmg: ${entity.damage.toFixed(1)} - Splash: ${(entity.splashRadius * GRID_SIZE).toFixed(0)}px`;
                if(entity.type === 'wall') info = `(Chỉ tăng máu)`;
                if(entity.type === 'castle') info = `(Nâng cấp hồi full máu)`;
                
                upgradeInfo.textContent = info;
                
                if (entity.level < 10 || entity.type === 'castle') { 
                    const cost = entity.getUpgradeCost();
                    upgradeButton.textContent = `Nâng Cấp (${cost}$)`;
                    upgradeButton.disabled = money < cost;
                } else {
                    upgradeButton.textContent = "Đã Tối Đa";
                    upgradeButton.disabled = true;
                }
                
                if(entity.type === 'castle') {
                    sellButton.style.display = 'none';
                } else {
                    sellButton.style.display = 'block';
                    const sellValue = entity.getSellValue();
                    sellButton.textContent = `Bán (${sellValue}$)`;
                }
            }
            
            function hideUpgradePanel() {
                selectedEntity = null;
                upgradePanel.style.display = 'none';
            }

            // --- Logic Ngày mới ---
            function startNewDay() {
                day++;
                isNight = false;
                hasSpawnedTonight = false; 
                logMessage(`Ngày ${day} bắt đầu!`);
                
                collectTaxes();
                
                let totalSoldiersToSpawn = 0;
                entities.filter(e => e.type === 'clinic').forEach(clinic => {
                    totalSoldiersToSpawn += clinic.level;
                });

                if (totalSoldiersToSpawn > 0) {
                    let spawned = 0;
                    const barracksList = entities.filter(e => e.type === 'barracks');
                    
                    for(const b of barracksList) {
                        if (spawned >= totalSoldiersToSpawn) break; 
                        
                        while(b.soldiers.length < b.maxSoldiers && spawned < totalSoldiersToSpawn) {
                            const spawnPos = findEmptyNeighbor(b.gridX, b.gridY);
                            if (spawnPos) {
                                const weapon = getWeaponByLevel(b.currentWeaponLevel);
                                const newSoldier = new Soldier(
                                    spawnPos.x * GRID_SIZE,
                                    spawnPos.y * GRID_SIZE,
                                    b, b.soldierBaseDamage, weapon
                                );
                                units.push(newSoldier);
                                b.soldiers.push(newSoldier);
                                population++;
                                spawned++;
                            } else {
                                break; 
                            }
                        }
                    }
                    
                    if (spawned > 0) {
                        logMessage(`Bệnh xá đã đào tạo ${spawned} lính mới!`);
                    }
                }
                
                if (day > 1) {
                    enemyStats.spawnCount = 3 + 3 * (day - 1);
                    enemyStats.health = 5 + 2 * (day - 1);
                    enemyStats.damage = 2 + 0.5 * (day - 1);
                }
            }
            
            function collectTaxes() {
                let totalIncome = 10; 
                let buffMultiplier = 1.0; 
                entities.filter(e => e.type === 'farmplot').forEach(plot => {
                    buffMultiplier += plot.buffBonus; 
                });
                
                entities.forEach(e => {
                    if (e.income) {
                        let income = e.income;
                        if(e.type === 'house' || e.type === 'farm') {
                             totalIncome += income * buffMultiplier;
                        } else {
                             totalIncome += income;
                        }
                    }
                });
                money += Math.floor(totalIncome);
                logMessage(`Đã nhận ${Math.floor(totalIncome)}$ thuế. (Hệ số: ${buffMultiplier.toFixed(1)}x)`);
            }

            // --- Logic Kẻ thù ---
            function spawnEnemiesOnce() {
                hasSpawnedTonight = true; 
                logMessage(`Cảnh báo! Kẻ thù đang tấn công!`);
                
                // 1. QUÁI ĐỎ CƠ BẢN
                let totalCount = enemyStats.spawnCount;
                const spawnCounts = [0, 0, 0, 0];
                for(let i=0; i < totalCount; i++) {
                    spawnCounts[i % 4]++;
                }
                
                for(let side = 0; side < 4; side++) {
                    const count = spawnCounts[side];
                    if (count === 0) continue;
                    
                    let spawnZone;
                    if(side === 0) spawnZone = { x: [MID_X-1, MID_X], y: [0, 0] }; // Trên
                    else if(side === 1) spawnZone = { x: [MID_X-1, MID_X], y: [ROWS - 1, ROWS - 1] }; // Dưới
                    else if(side === 2) spawnZone = { x: [0, 0], y: [MID_Y-1, MID_Y] }; // Trái
                    else spawnZone = { x: [COLS - 1, COLS - 1], y: [MID_Y-1, MID_Y] }; // Phải
                    
                    for (let i = 0; i < count; i++) {
                        const gridX = spawnZone.x[Math.floor(Math.random() * spawnZone.x.length)];
                        const gridY = spawnZone.y[Math.floor(Math.random() * spawnZone.y.length)];
                        const weapon = getRandomWeapon();
                        
                        units.push(new Enemy(
                            gridX * GRID_SIZE, gridY * GRID_SIZE, 
                            enemyStats.health + (Math.random() * day), 
                            enemyStats.damage, enemyStats.speed, weapon
                        ));
                    }
                }
            
                // 2. ORC (từ Đêm 6)
                if (day >= 6) {
                    const orcPerSide = Math.floor((day - 4) / 2);
                    if (orcPerSide > 0) {
                        for (let side = 0; side < 4; side++) {
                            for (let k = 0; k < orcPerSide; k++) {
                                let spawnZone;
                                if(side === 0) spawnZone = { x: [MID_X-1, MID_X], y: [0, 0] }; 
                                else if(side === 1) spawnZone = { x: [MID_X-1, MID_X], y: [ROWS - 1, ROWS - 1] }; 
                                else if(side === 2) spawnZone = { x: [0, 0], y: [MID_Y-1, MID_Y] }; 
                                else spawnZone = { x: [COLS - 1, COLS - 1], y: [MID_Y-1, MID_Y] }; 
                                
                                const gridX = spawnZone.x[Math.floor(Math.random() * spawnZone.x.length)];
                                const gridY = spawnZone.y[Math.floor(Math.random() * spawnZone.y.length)];
                                
                                units.push(new OrcEnemy(gridX * GRID_SIZE, gridY * GRID_SIZE));
                            }
                        }
                        logMessage(`ORC đã xuất hiện! (${orcPerSide} mỗi hướng)`);
                    }
                }

                // 3. MÁY BẮN ĐÁ (từ Đêm 10)
                if (day >= 10) {
                    const catapultCount = Math.floor((day - 5) / 5);
                    for (let c = 0; c < catapultCount; c++) {
                        const side = Math.floor(Math.random() * 4);
                        let spawnZone;
                        if(side === 0) spawnZone = { x: [MID_X-1, MID_X], y: [0, 0] }; 
                        else if(side === 1) spawnZone = { x: [MID_X-1, MID_X], y: [ROWS - 1, ROWS - 1] };
                        else if(side === 2) spawnZone = { x: [0, 0], y: [MID_Y-1, MID_Y] };
                        else spawnZone = { x: [COLS - 1, COLS - 1], y: [MID_Y-1, MID_Y] };
                        
                        const gridX = spawnZone.x[Math.floor(Math.random() * spawnZone.x.length)];
                        const gridY = spawnZone.y[Math.floor(Math.random() * spawnZone.y.length)];
                        
                        units.push(new EnemyCatapult(gridX * GRID_SIZE, gridY * GRID_SIZE));
                    }
                    if (catapultCount > 0) logMessage(`Máy bắn đá của địch: ${catapultCount}!`);
                }
            }

            // --- Xử lý Sự kiện (Events) ---
            function setupEventListeners() {
                // Chọn item trong shop
                shopItems.forEach(item => {
                    item.addEventListener('click', () => {
                        if(item.classList.contains('disabled')) return;
                        
                        hideUpgradePanel();
                        selectedSoldier = null; 
                        shopItems.forEach(i => i.classList.remove('selected'));
                        
                        selectedShopItem = {
                            type: item.dataset.type,
                            cost: parseInt(item.dataset.cost)
                        };
                        item.classList.add('selected');
                        logMessage(`Đã chọn: ${selectedShopItem.type}. (Click phải để hủy)`);
                    });
                });

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mousePos.x = e.clientX - rect.left;
                    mousePos.y = e.clientY - rect.top;
                    mousePos.gridX = Math.floor(mousePos.x / GRID_SIZE);
                    mousePos.gridY = Math.floor(mousePos.y / GRID_SIZE);
                });

                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); 
                    
                    if (selectedSoldier) {
                        selectedSoldier.manualTargetPos = { x: mousePos.x, y: mousePos.y };
                        selectedSoldier.target = null; 
                        logMessage("Lính đã nhận lệnh di chuyển!");
                    } 
                    else if (selectedShopItem) {
                        selectedShopItem = null;
                        shopItems.forEach(i => i.classList.remove('selected'));
                        logMessage("Đã hủy xây dựng.");
                    } else if (selectedEntity) {
                        hideUpgradePanel();
                    } else {
                        selectedSoldier = null; 
                    }
                });

                canvas.addEventListener('click', () => {
                    const x = mousePos.gridX;
                    const y = mousePos.gridY;
                    
                    if (selectedShopItem) {
                        buildEntity(x, y);
                    } else {
                        const soldier = getSoldierAt(mousePos.x, mousePos.y);
                        if (soldier) {
                            selectedSoldier = soldier;
                            selectedEntity = null;
                            hideUpgradePanel();
                            logMessage("Đã chọn lính! (Click phải để di chuyển)");
                        } else {
                            const entity = getEntityAt(x, y);
                            // --- SỬA LỖI TÀU CHIẾN ---
                            // Cho phép chọn Tàu Chiến (warship) để xem thông số
                            if(entity && (entity.type !== 'warship')) { 
                                selectEntityForUpgrade(entity);
                            } else if (entity && entity.type === 'warship') {
                                // Nếu click vào tàu, chọn Xưởng Tàu của nó
                                selectEntityForUpgrade(entity.shipyard);
                            }
                            // --- KẾT THÚC SỬA LỖI ---
                            else {
                                hideUpgradePanel();
                                selectedSoldier = null; 
                            }
                        }
                    }
                });
                
                upgradeButton.addEventListener('click', () => {
                    if(selectedEntity) {
                        selectedEntity.upgrade();
                        if(selectedEntity.type === 'castle') {
                            maxCastleHealth = selectedEntity.maxHealth;
                            castleHealth = selectedEntity.health;
                            castleLevel = selectedEntity.level;
                        }
                        // --- SỬA LỖI TÀU CHIẾN ---
                        // Cập nhật lại panel ngay sau khi nâng cấp xưởng tàu
                        // để hiển thị thông số mới của tàu
                        if (selectedEntity.type === 'shipyard') {
                            showUpgradePanel(selectedEntity.warship); 
                            // Trick: Hiển thị thông số tàu, nhưng vẫn giữ xưởng tàu được chọn
                            selectedEntity = selectedEntity; 
                        }
                        // --- KẾT THÚC SỬA LỖI ---
                    }
                });
                
                sellButton.addEventListener('click', () => {
                    if(selectedEntity) {
                        const sellValue = selectedEntity.getSellValue();
                        money += sellValue;
                        logMessage(`Đã bán ${selectedEntity.type} thu về ${sellValue}$`);
                        selectedEntity.destroy();
                        hideUpgradePanel();
                    }
                });
            }
            
            function buildEntity(x, y) {
                if (!canBuildAt(selectedShopItem.type, x, y)) {
                    logMessage("Không thể xây ở đây!");
                    return;
                }
                
                if (money < selectedShopItem.cost) {
                    logMessage("Không đủ tiền!");
                    return;
                }
                
                money -= selectedShopItem.cost;
                
                const oldGridValue = grid[y][x];
                
                let newEntity;
                switch(selectedShopItem.type) {
                    case 'house':
                        newEntity = new House(x, y, 'house', 10, 30, 3); 
                        break;
                    case 'farm':
                        newEntity = new House(x, y, 'farm', 20, 40, 5); 
                        break;
                    case 'farmplot':
                        newEntity = new FarmPlot(x, y);
                        break;
                    case 'clinic':
                        newEntity = new Clinic(x, y);
                        break;
                    case 'barracks':
                        newEntity = new Barracks(x, y);
                        break;
                    case 'wall':
                        newEntity = new Wall(x, y); 
                        if (oldGridValue === 1) grid[y][x] = 6; // Wall on Path
                        else grid[y][x] = 3; // Wall on Grass
                        break;
                    case 'tower':
                        newEntity = new Tower(x, y);
                        break;
                    case 'shipyard':
                        newEntity = new Shipyard(x, y);
                        grid[y][x] = 3; 
                        break;
                }
                
                if(newEntity && newEntity.type !== 'wall' && newEntity.type !== 'shipyard') {
                    grid[y][x] = 3; // 3 = Đã xây
                }
                
                if(newEntity) {
                    entities.push(newEntity);
                    logMessage(`Đã xây ${selectedShopItem.type}!`);
                }
                
                selectedShopItem = null;
                shopItems.forEach(i => i.classList.remove('selected'));
            }

            // --- Hàm Tiện ích ---
            
            function canBuildAt(type, x, y) {
                if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
                
                const gridValue = grid[y][x];
                
                // Không thể xây nếu đã có công trình hoặc là Đá (2, 3, 5, 6)
                if (gridValue === 2 || gridValue === 3 || gridValue === 5 || gridValue === 6) return false; 
                
                if(type === 'clinic') {
                    const clinicCount = entities.filter(e => e.type === 'clinic').length;
                    if(clinicCount >= 3) {
                        logMessage("Đã đạt giới hạn 3 Bệnh xá!");
                        return false;
                    }
                }
                
                // Wall có thể đặt trên Cỏ (0) hoặc Đường (1)
                if(type === 'wall') {
                    return gridValue === 0 || gridValue === 1;
                }
                
                // Xưởng tàu phải đặt trên Cỏ (0) VÀ cạnh Nước (4)
                if(type === 'shipyard') {
                    return gridValue === 0 && (
                        (y > 0 && grid[y-1][x] === 4) ||
                        (y < ROWS - 1 && grid[y+1][x] === 4) ||
                        (x > 0 && grid[y][x-1] === 4) ||
                        (x < COLS - 1 && grid[y][x+1] === 4)
                    );
                }
                
                // Các công trình khác chỉ đặt trên Cỏ (0)
                return gridValue === 0;
            }
            
            function findEmptyNeighbor(x, y, type = 0) { // 0=Cỏ, 4=Nước
                 const neighbors = [
                    {x: x, y: y - 1}, {x: x, y: y + 1},
                    {x: x - 1, y: y}, {x: x + 1, y: y},
                    {x: x - 1, y: y - 1}, {x: x + 1, y: y - 1},
                    {x: x - 1, y: y + 1}, {x: x + 1, y: y + 1}
                ];
                for (const n of neighbors) {
                    if(n.x >= 0 && n.x < COLS && n.y >= 0 && n.y < ROWS) {
                        if(grid[n.y][n.x] === type) {
                            return n;
                        }
                    }
                }
                return null;
            }

            function getDistance(obj1, obj2, isPoint = false) {
                const obj1_centerX = obj1.x + (obj1.size || GRID_SIZE) / 2;
                const obj1_centerY = obj1.y + (obj1.size || GRID_SIZE) / 2;
                
                let obj2_centerX, obj2_centerY;
                
                if (isPoint) {
                    obj2_centerX = obj2.x; // obj2 là {x, y}
                    obj2_centerY = obj2.y;
                } else {
                    obj2_centerX = obj2.x + (obj2.size || GRID_SIZE) / 2;
                    obj2_centerY = obj2.y + (obj2.size || GRID_SIZE) / 2;
                }
                
                const dx = obj1_centerX - obj2_centerX;
                const dy = obj1_centerY - obj2_centerY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            function findNearestTarget(source, range, targetType) {
                let nearest = null;
                let minDist = range;
                
                let targets = [];
                if (targetType === 'soldier') {
                    targets = units.filter(u => u.type === 'soldier' && u.health > 0);
                } else if (targetType === 'enemy') {
                    targets = units.filter(u => u.type === 'enemy' && u.health > 0);
                } else if (targetType === 'any_enemy') {
                    targets = units.filter(u => (u.type.includes('enemy') || u.type === 'orc' || u.type === 'catapult') && u.health > 0);
                }
                
                for (const target of targets) {
                    if (target.health <= 0) continue; 
                    const dist = getDistance(source, target);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = target;
                    }
                }
                return nearest;
            }

            function findNearestEntity(source, targets, range) {
                let nearest = null;
                let minDist = range;

                for (const target of targets) {
                    if (target.health <= 0) continue;
                    const dist = getDistance(source, target);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = target;
                    }
                }
                return nearest;
            }
            
            function getEntityAt(gridX, gridY) {
                // --- SỬA LỖI TƯỜNG (H) ---
                // Phải tìm Lâu đài trước, vì Lâu đài (2) và Tường (3, 6) có thể
                // chiếm cùng 1 ô logic (nhưng Lâu đài đè lên)
                if (gridX >= MID_X - 1 && gridX <= MID_X && gridY >= MID_Y - 1 && gridY <= MID_Y) {
                    return entities.find(e => e.type === 'castle');
                }
                
                // Tìm các công trình khác
                return entities.find(e => {
                    return e.gridX === gridX && e.gridY === gridY;
                });
                // --- KẾT THÚC SỬA LỖI TƯỜNG (H) ---
            }
            
            function getSoldierAt(pixelX, pixelY) {
                for (const soldier of units) {
                    if (soldier.type !== 'soldier' || soldier.health <= 0) continue;
                    
                    const centerX = soldier.x + GRID_SIZE / 2;
                    const centerY = soldier.y + GRID_SIZE / 2;
                    const radius = soldier.size / 2;
                    
                    const dx = pixelX - centerX;
                    const dy = pixelY - centerY;
                    
                    if (Math.sqrt(dx * dx + dy * dy) < radius) {
                        return soldier;
                    }
                }
                return null;
            }
            
            function selectEntityForUpgrade(entity) {
                if(entity) {
                    // --- SỬA LỖI TÀU CHIẾN ---
                    // Nếu là xưởng tàu, hiển thị thông số Tàu Chiến
                    if (entity.type === 'shipyard' && entity.warship) {
                        showUpgradePanel(entity.warship);
                        selectedEntity = entity; // Giữ xưởng tàu được chọn
                    } 
                    // Nếu là tàu chiến, hiển thị thông số tàu
                    else if (entity.type === 'warship') {
                        showUpgradePanel(entity);
                        selectedEntity = entity.shipyard; // Chọn xưởng tàu
                    }
                    // --- KẾT THÚC SỬA LỖI ---
                    else {
                        showUpgradePanel(entity);
                    }
                    selectedShopItem = null;
                    selectedSoldier = null; 
                    shopItems.forEach(i => i.classList.remove('selected'));
                }
            }

            function logMessage(msg) {
                messageDisplay.textContent = msg;
            }
            
            // --- Bắt đầu Game ---
            init();
        });
    </script>
</body>
</html>